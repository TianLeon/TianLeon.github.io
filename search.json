[{"title":"git简介与安装","url":"/2020/04/30/git/README/","content":"git简介与安装\n最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。\n要使用Git，第一步当然是安装Git了。根据你当前使用的平台来阅读下面的文字：\n在Linux上安装Git首先，你可以试着输入git，看看系统有没有安装Git：\n$ gitThe program &#x27;git&#x27; is currently not installed. You can install it by typing:sudo apt-get install git\n\n像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。\n如果你碰巧用Debian或Ubuntu Linux，通过一条sudo apt-get install git就可以直接完成Git的安装，非常简单。\n老一点的Debian或Ubuntu Linux，要把命令改为sudo apt-get install git-core，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫git-core了。由于Git名气实在太大，后来就把GNU Interactive Tools改成gnuit，git-core正式改为git。\n如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。\n在Mac OS X上安装Git如果你正在使用Mac做开发，有两种安装Git的方法。\n一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/。\n第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。\nXcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的！\n在Windows上安装Git在Windows上使用Git，可以从Git官网直接下载安装程序，然后按默认选项安装即可。\n安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\n安装完成后，还需要最后一步设置，在命令行输入：\n$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot;\n\n因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。\n注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。\n Git可以安装在哪些操作系统上？\n Linux\n macOS\n Solaris\n Windows\n Raspberry Pi\n","categories":["git"]},{"title":"Feature分支","url":"/2020/04/30/git/feature%E5%88%86%E6%94%AF/","content":"Feature分支\n软件开发中，总有无穷无尽的新的功能要不断添加进来。\n添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。\n现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。\n于是准备开发：\n$ git switch -c feature-vulcanSwitched to a new branch &#x27;feature-vulcan&#x27;\n\n5分钟后，开发完毕：\n$ git add vulcan.py$ git statusOn branch feature-vulcanChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)\tnew file:   vulcan.py$ git commit -m &quot;add feature vulcan&quot;[feature-vulcan 287773e] add feature vulcan 1 file changed, 2 insertions(+) create mode 100644 vulcan.py\n\n切回dev，准备合并：\n$ git switch dev\n\n一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。\n但是！\n就在此时，接到上级命令，因经费不足，新功能必须取消！\n虽然白干了，但是这个包含机密资料的分支还是必须就地销毁：\n$ git branch -d feature-vulcanerror: The branch &#x27;feature-vulcan&#x27; is not fully merged.If you are sure you want to delete it, run &#x27;git branch -D feature-vulcan&#x27;.\n\n销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。。\n现在我们强行删除：\n$ git branch -D feature-vulcanDeleted branch feature-vulcan (was 287773e).\n\n终于删除成功！\n小结开发一个新feature，最好新建一个分支；\n如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。\n","categories":["git"]},{"title":"Bug分支","url":"/2020/04/30/git/bug%E5%88%86%E6%94%AF/","content":"Bug分支\n软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。\n当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交：\n$ git statusOn branch devChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)\tnew file:   hello.pyChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)\tmodified:   readme.txt\n\n并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？\n幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：\n$ git stashSaved working directory and index state WIP on dev: f52c633 add merge\n\n现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。\n首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：\n$ git checkout masterSwitched to branch &#x27;master&#x27;Your branch is ahead of &#x27;origin/master&#x27; by 6 commits.  (use &quot;git push&quot; to publish your local commits)$ git checkout -b issue-101Switched to a new branch &#x27;issue-101&#x27;\n\n现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：\n$ git add readme.txt $ git commit -m &quot;fix bug 101&quot;[issue-101 4c805e2] fix bug 101 1 file changed, 1 insertion(+), 1 deletion(-)\n\n修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：\n$ git switch masterSwitched to branch &#x27;master&#x27;Your branch is ahead of &#x27;origin/master&#x27; by 6 commits.  (use &quot;git push&quot; to publish your local commits)$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101Merge made by the &#x27;recursive&#x27; strategy. readme.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)\n\n太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！\n$ git switch devSwitched to branch &#x27;dev&#x27;$ git statusOn branch devnothing to commit, working tree clean\n\n工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：\n$ git stash liststash@&#123;0&#125;: WIP on dev: f52c633 add merge\n\n工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：\n一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；\n另一种方式是用git stash pop，恢复的同时把stash内容也删了：\n$ git stash popOn branch devChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)\tnew file:   hello.pyChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)\tmodified:   readme.txtDropped refs/stash@&#123;0&#125; (5d677e2ee266f39ea296182fb2354265b91b3b2a)\n\n再用git stash list查看，就看不到任何stash内容了：\n$ git stash list\n\n你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：\n$ git stash apply stash@&#123;0&#125;\n\n\n\n在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。\n那怎么在dev分支上修复同样的bug？重复操作一次，提交不就行了？\n有木有更简单的方法？\n有！\n同样的bug，要在dev上修复，我们只需要把4c805e2 fix bug 101这个提交所做的修改“复制”到dev分支。注意：我们只想复制4c805e2 fix bug 101这个提交所做的修改，并不是把整个master分支merge过来。\n为了方便操作，Git专门提供了一个cherry-pick命令，让我们能复制一个特定的提交到当前分支：\n$ git branch* dev  master$ git cherry-pick 4c805e2[master 1d4b803] fix bug 101 1 file changed, 1 insertion(+), 1 deletion(-)\n\nGit自动给dev分支做了一次提交，注意这次提交的commit是1d4b803，它并不同于master的4c805e2，因为这两个commit只是改动相同，但确实是两个不同的commit。用git cherry-pick，我们就不需要在dev分支上手动再把修bug的过程重复一遍。\n有些聪明的童鞋会想了，既然可以在master分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在master分支上“重放”行不行？当然可以，不过你仍然需要git stash命令保存现场，才能从dev分支切换到master分支。\n小结修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；\n当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；\n在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick 命令，把bug提交的修改“复制”到当前分支，避免重复劳动。\n","categories":["git"]},{"title":"从远程库克隆","url":"/2020/04/30/git/%E4%BB%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%85%8B%E9%9A%86/","content":"从远程库克隆\n上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。\n现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。\n首先，登陆GitHub，创建一个新的仓库，名字叫gitskills：\n我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件：\n现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库：\n$ git clone git@github.com:michaelliao/gitskills.gitCloning into &#x27;gitskills&#x27;...remote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3Receiving objects: 100% (3/3), done.\n\n注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了：\n$ cd gitskills$ lsREADME.md\n\n\n\n如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。\n你也许还注意到，GitHub给出的地址不止一个，还可以用https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。\n使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。\n小结要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。\nGit支持多种协议，包括https，但ssh协议速度最快。\n","categories":["git"]},{"title":"Rebase","url":"/2020/04/30/git/rebase/","content":"Rebase\n在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。\n每次合并再push后，分支变成了这样：\n$ git log --graph --pretty=oneline --abbrev-commit* d1be385 (HEAD -&gt; master, origin/master) init hello*   e5e69f1 Merge branch &#x27;dev&#x27;|\\  | *   57c53ab (origin/dev, dev) fix env conflict| |\\  | | * 7a5e5dd add env| * | 7bd91f1 add new env| |/  * |   12a631b merged bug fix 101|\\ \\  | * | 4c805e2 fix bug 101|/ /  * |   e1e9c68 merge with no-ff|\\ \\  | |/  | * f52c633 add merge|/  *   cf810e4 conflict fixed\n\n总之看上去很乱，有强迫症的童鞋会问：为什么Git的提交历史不能是一条干净的直线？\n其实是可以做到的！\nGit有一种称为rebase的操作，有人把它翻译成“变基”。\n先不要随意展开想象。我们还是从实际问题出发，看看怎么把分叉的提交变成直线。\n在和远程分支同步后，我们对hello.py这个文件做了两次提交。用git log命令看看：\n$ git log --graph --pretty=oneline --abbrev-commit* 582d922 (HEAD -&gt; master) add author* 8875536 add comment* d1be385 (origin/master) init hello*   e5e69f1 Merge branch &#x27;dev&#x27;|\\  | *   57c53ab (origin/dev, dev) fix env conflict| |\\  | | * 7a5e5dd add env| * | 7bd91f1 add new env...\n\n注意到Git用(HEAD -&gt; master)和(origin/master)标识出当前分支的HEAD和远程origin的位置分别是582d922 add author和d1be385 init hello，本地分支比远程分支快两个提交。\n现在我们尝试推送本地分支：\n$ git push origin masterTo github.com:michaelliao/learngit.git ! [rejected]        master -&gt; master (fetch first)error: failed to push some refs to &#x27;git@github.com:michaelliao/learngit.git&#x27;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &#x27;git pull ...&#x27;) before pushing again.hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.\n\n很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下：\n$ git pullremote: Counting objects: 3, done.remote: Compressing objects: 100% (1/1), done.remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0Unpacking objects: 100% (3/3), done.From github.com:michaelliao/learngit   d1be385..f005ed4  master     -&gt; origin/master * [new tag]         v1.0       -&gt; v1.0Auto-merging hello.pyMerge made by the &#x27;recursive&#x27; strategy. hello.py | 1 + 1 file changed, 1 insertion(+)\n\n再用git status看看状态：\n$ git statusOn branch masterYour branch is ahead of &#x27;origin/master&#x27; by 3 commits.  (use &quot;git push&quot; to publish your local commits)nothing to commit, working tree clean\n\n加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。\n用git log看看：\n$ git log --graph --pretty=oneline --abbrev-commit*   e0ea545 (HEAD -&gt; master) Merge branch &#x27;master&#x27; of github.com:michaelliao/learngit|\\  | * f005ed4 (origin/master) set exit=1* | 582d922 add author* | 8875536 add comment|/  * d1be385 init hello...\n\n对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支push到远程，有没有问题？\n有！\n什么问题？\n不好看！\n有没有解决方法？\n有！\n这个时候，rebase就派上了用场。我们输入命令git rebase试试：\n$ git rebaseFirst, rewinding head to replay your work on top of it...Applying: add commentUsing index info to reconstruct a base tree...M\thello.pyFalling back to patching base and 3-way merge...Auto-merging hello.pyApplying: add authorUsing index info to reconstruct a base tree...M\thello.pyFalling back to patching base and 3-way merge...Auto-merging hello.py\n\n输出了一大堆操作，到底是啥效果？再用git log看看：\n$ git log --graph --pretty=oneline --abbrev-commit* 7e61ed4 (HEAD -&gt; master) add author* 3611cfe add comment* f005ed4 (origin/master) set exit=1* d1be385 init hello...\n\n原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了f005ed4 (origin/master) set exit=1之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于d1be385 init hello，而是基于f005ed4 (origin/master) set exit=1，但最后的提交7e61ed4内容是一致的。\n这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。\n最后，通过push操作把本地分支推送到远程：\nMac:~/learngit michael$ git push origin masterCounting objects: 6, done.Delta compression using up to 4 threads.Compressing objects: 100% (5/5), done.Writing objects: 100% (6/6), 576 bytes | 576.00 KiB/s, done.Total 6 (delta 2), reused 0 (delta 0)remote: Resolving deltas: 100% (2/2), completed with 1 local object.To github.com:michaelliao/learngit.git   f005ed4..7e61ed4  master -&gt; master\n\n再用git log看看效果：\n$ git log --graph --pretty=oneline --abbrev-commit* 7e61ed4 (HEAD -&gt; master, origin/master) add author* 3611cfe add comment* f005ed4 set exit=1* d1be385 init hello...\n\n远程分支的提交历史也是一条直线。\n小结\nrebase操作可以把本地未push的分叉提交历史整理成直线；\nrebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。\n\n","categories":["git"]},{"title":"分支管理策略","url":"/2020/04/30/git/%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5%E7%AE%A1%E7%90%86/","content":"分支管理策略\n通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。\n如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。\n下面我们实战一下--no-ff方式的git merge：\n首先，仍然创建并切换dev分支：\n$ git switch -c devSwitched to a new branch &#x27;dev&#x27;\n\n修改readme.txt文件，并提交一个新的commit：\n$ git add readme.txt $ git commit -m &quot;add merge&quot;[dev f52c633] add merge 1 file changed, 1 insertion(+)\n\n现在，我们切换回master：\n$ git switch masterSwitched to branch &#x27;master&#x27;\n\n准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward：\n$ git merge --no-ff -m &quot;merge with no-ff&quot; devMerge made by the &#x27;recursive&#x27; strategy. readme.txt | 1 + 1 file changed, 1 insertion(+)\n\n因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。\n合并后，我们用git log看看分支历史：\n$ git log --graph --pretty=oneline --abbrev-commit*   e1e9c68 (HEAD -&gt; master) merge with no-ff|\\  | * f52c633 (dev) add merge|/  *   cf810e4 conflict fixed...\n\n可以看到，不使用Fast forward模式，merge后就像这样：\n\n分支策略在实际开发中，我们应该按照几个基本原则进行分支管理：\n首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；\n那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；\n你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。\n所以，团队合作的分支看起来就像这样：\n\n小结Git分支十分强大，在团队开发中应该充分应用。\n合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。\n","categories":["git"]},{"title":"创建标签","url":"/2020/04/30/git/%E5%88%9B%E5%BB%BA%E6%A0%87%E7%AD%BE/","content":"创建标签\n在Git中打标签非常简单，首先，切换到需要打标签的分支上：\n$ git branch* dev  master$ git checkout masterSwitched to branch &#x27;master&#x27;\n\n然后，敲命令git tag 就可以打一个新标签：\n$ git tag v1.0\n\n可以用命令git tag查看所有标签：\n$ git tagv1.0\n\n默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？\n方法是找到历史提交的commit id，然后打上就可以了：\n$ git log --pretty=oneline --abbrev-commit12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 1014c805e2 fix bug 101e1e9c68 merge with no-fff52c633 add mergecf810e4 conflict fixed5dc6824 &amp; simple14096d0 AND simpleb17d20e branch testd46f35e remove test.txtb84166e add test.txt519219b git tracks changese43a48b understand how stage works1094adb append GPLe475afc add distributedeaadf4e wrote a readme file\n\n比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令：\n$ git tag v0.9 f52c633\n\n再用命令git tag查看标签：\n$ git tagv0.9v1.0\n\n注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show 查看标签信息：\n$ git show v0.9commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Fri May 18 21:56:54 2018 +0800    add mergediff --git a/readme.txt b/readme.txt...\n\n可以看到，v0.9确实打在add merge这次提交上。\n还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：\n$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb\n\n用命令git show 可以看到说明文字：\n$ git show v0.1tag v0.1Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Fri May 18 22:48:43 2018 +0800version 0.1 releasedcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Fri May 18 21:06:15 2018 +0800    append GPLdiff --git a/readme.txt b/readme.txt...\n\n 注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。\n小结\n命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id；\n命令git tag -a  -m &quot;blablabla...&quot;可以指定标签信息；\n命令git tag可以查看所有标签。\n\n","categories":["git"]},{"title":"创建与合并分支","url":"/2020/04/30/git/%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF%E4%B8%8E%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/","content":"创建与合并分支\n在[版本回退]里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。\n一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：\n\n每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。\n当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：\n\n你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！\n不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：\n\n假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：\n\n所以Git合并分支也很快！就改改指针，工作区内容也不变！\n合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：\n\n真是太神奇了，你看得出来有些提交是通过分支完成的吗？\n下面开始实战。\n首先，我们创建dev分支，然后切换到dev分支：\n$ git checkout -b devSwitched to a new branch &#x27;dev&#x27;\n\ngit checkout命令加上-b参数表示创建并切换，相当于以下两条命令：\n$ git branch dev$ git checkout devSwitched to branch &#x27;dev&#x27;\n\n然后，用git branch命令查看当前分支：\n$ git branch* dev  master\n\ngit branch命令会列出所有分支，当前分支前面会标一个*号。\n然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：\nCreating a new branch is quick.\n\n然后提交：\n$ git add readme.txt $ git commit -m &quot;branch test&quot;[dev b17d20e] branch test 1 file changed, 1 insertion(+)\n\n现在，dev分支的工作完成，我们就可以切换回master分支：\n$ git checkout masterSwitched to branch &#x27;master&#x27;\n\n切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：\n\n现在，我们把dev分支的工作成果合并到master分支上：\n$ git merge devUpdating d46f35e..b17d20eFast-forward readme.txt | 1 + 1 file changed, 1 insertion(+)\n\ngit merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。\n注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。\n当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。\n合并完成后，就可以放心地删除dev分支了：\n$ git branch -d devDeleted branch dev (was b17d20e).\n\n删除后，查看branch，就只剩下master分支了：\n$ git branch* master\n\n因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。\nswitch我们注意到切换分支使用git checkout ，而前面讲过的撤销修改则是git checkout -- ，同一个命令，有两种作用，确实有点令人迷惑。\n实际上，切换分支这个动作，用switch更科学。因此，最新版本的Git提供了新的git switch命令来切换分支：\n创建并切换到新的dev分支，可以使用：\n$ git switch -c dev\n\n直接切换到已有的master分支，可以使用：\n$ git switch master\n\n使用新的git switch命令，比git checkout要更容易理解。\n小结Git鼓励大量使用分支：\n查看分支：git branch\n创建分支：git branch \n切换分支：git checkout 或者git switch \n创建+切换分支：git checkout -b 或者git switch -c \n合并某分支到当前分支：git merge \n删除分支：git branch -d \n","categories":["git"]},{"title":"创建版本库","url":"/2020/04/30/git/%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93/","content":"创建版本库\n什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。\n所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：\n$ mkdir learngit$ cd learngit$ pwd/Users/michael/learngit\n\npwd命令用于显示当前目录。在我的Mac上，这个仓库位于/Users/michael/learngit。\n 如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。\n第二步，通过git init命令把这个目录变成Git可以管理的仓库：\n$ git initInitialized empty Git repository in /Users/michael/learngit/.git/\n\n瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。\n如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。\n也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。\n把文件添加到版本库首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。\n不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。\n因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。\n使用Windows的童鞋要特别注意：\n千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载Notepad++代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可：\n言归正传，现在我们编写一个readme.txt文件，内容如下：\nGit is a version control system.Git is free software.\n\n一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。\n和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。\n第一步，用命令git add告诉Git，把文件添加到仓库：\n$ git add readme.txt\n\n执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。\n第二步，用命令git commit告诉Git，把文件提交到仓库：\n$ git commit -m &quot;wrote a readme file&quot;[master (root-commit) eaadf4e] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt\n\n简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。\n嫌麻烦不想输入-m &quot;xxx&quot;行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。\ngit commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。\n为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：\n$ git add file1.txt$ git add file2.txt file3.txt$ git commit -m &quot;add 3 files.&quot;\n\n小结现在总结一下今天学的两点内容：\n初始化一个Git仓库，使用git init命令。\n添加文件到Git仓库，分两步：\n\n使用命令git add ，注意，可反复多次使用，添加多个文件；\n使用命令git commit -m ，完成。\n\n","categories":["git"]},{"title":"删除文件","url":"/2020/04/30/git/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/","content":"删除文件\n在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：\n$ git add test.txt$ git commit -m &quot;add test.txt&quot;[master b84166e] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt\n\n一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：\n$ rm test.txt\n\n这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：\n$ git statusOn branch masterChanges not staged for commit:  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)\tdeleted:    test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)\n\n现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：\n$ git rm test.txtrm &#x27;test.txt&#x27;$ git commit -m &quot;remove test.txt&quot;[master d46f35e] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt\n\n现在，文件就从版本库中被删除了。\n 小提示：先手动删除文件，然后使用git rm 和git add效果是一样的。\n另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：\n$ git checkout -- test.txt\n\ngit checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。\n\n注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！\n\n小结命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。\n","categories":["git"]},{"title":"多人协作","url":"/2020/04/30/git/%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C/","content":"多人协作\n当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。\n要查看远程库的信息，用git remote：\n$ git remoteorigin\n\n或者，用git remote -v显示更详细的信息：\n$ git remote -vorigin  git@github.com:michaelliao/learngit.git (fetch)origin  git@github.com:michaelliao/learngit.git (push)\n\n上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。\n推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：\n$ git push origin master\n\n如果要推送其他分支，比如dev，就改成：\n$ git push origin dev\n\n但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？\n\nmaster分支是主分支，因此要时刻与远程同步；\ndev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；\nbug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；\nfeature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。\n\n总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！\n抓取分支多人协作时，大家都会往master和dev分支上推送各自的修改。\n现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：\n$ git clone git@github.com:michaelliao/learngit.gitCloning into &#x27;learngit&#x27;...remote: Counting objects: 40, done.remote: Compressing objects: 100% (21/21), done.remote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0Receiving objects: 100% (40/40), done.Resolving deltas: 100% (14/14), done.\n\n当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看：\n$ git branch* master\n\n现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：\n$ git checkout -b dev origin/dev\n\n现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：\n$ git add env.txt$ git commit -m &quot;add env&quot;[dev 7a5e5dd] add env 1 file changed, 1 insertion(+) create mode 100644 env.txt$ git push origin devCounting objects: 3, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 308 bytes | 308.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git   f52c633..7a5e5dd  dev -&gt; dev\n\n\n\n你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：\n$ cat env.txtenv$ git add env.txt$ git commit -m &quot;add new env&quot;[dev 7bd91f1] add new env 1 file changed, 1 insertion(+) create mode 100644 env.txt$ git push origin devTo github.com:michaelliao/learngit.git ! [rejected]        dev -&gt; dev (non-fast-forward)error: failed to push some refs to &#x27;git@github.com:michaelliao/learngit.git&#x27;hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: &#x27;git pull ...&#x27;) before pushing again.hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.\n\n推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：\n$ git pullThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details.    git pull &lt;remote&gt; &lt;branch&gt;If you wish to set tracking information for this branch you can do so with:    git branch --set-upstream-to=origin/&lt;branch&gt; dev\n\ngit pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：\n$ git branch --set-upstream-to=origin/dev devBranch &#x27;dev&#x27; set up to track remote branch &#x27;dev&#x27; from &#x27;origin&#x27;.\n\n再pull：\n$ git pullAuto-merging env.txtCONFLICT (add/add): Merge conflict in env.txtAutomatic merge failed; fix conflicts and then commit the result.\n\n这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：\n$ git commit -m &quot;fix env conflict&quot;[dev 57c53ab] fix env conflict$ git push origin devCounting objects: 6, done.Delta compression using up to 4 threads.Compressing objects: 100% (4/4), done.Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.Total 6 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git   7a5e5dd..57c53ab  dev -&gt; dev\n\n\n\n因此，多人协作的工作模式通常是这样：\n\n首先，可以试图用git push origin 推送自己的修改；\n如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；\n如果合并有冲突，则解决冲突，并在本地提交；\n没有冲突或者解决掉冲突后，再用git push origin 推送就能成功！\n\n如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to  origin/。\n这就是多人协作的工作模式，一旦熟悉了，就非常简单。\n小结\n查看远程库信息，使用git remote -v；\n本地新建的分支如果不推送到远程，对其他人就是不可见的；\n从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；\n在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；\n建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；\n从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。\n\n","categories":["git"]},{"title":"工作区和暂存区","url":"/2020/04/30/git/%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E7%BC%93%E5%AD%98%E5%8C%BA/","content":"工作区和暂存区\nGit和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。\n先来看名词解释。\n工作区（Working Directory）就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区：\n版本库（Repository）工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。\nGit的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。\n\n分支和HEAD的概念我们以后再讲。\n前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：\n第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；\n第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。\n因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。\n你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。\n俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容：\nGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.\n\n然后，在工作区新增一个LICENSE文本文件（内容随便写）。\n先用git status查看一下状态：\n$ git statusOn branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)\tmodified:   readme.txtUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)\tLICENSEno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)\n\nGit非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked。\n现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下：\n$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)\tnew file:   LICENSE\tmodified:   readme.txt\n\n现在，暂存区的状态就变成这样了：\n\n所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。\n$ git commit -m &quot;understand how stage works&quot;[master e43a48b] understand how stage works 2 files changed, 2 insertions(+) create mode 100644 LICENSE\n\n一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：\n$ git statusOn branch masternothing to commit, working tree clean\n\n现在版本库变成了这样，暂存区就没有任何内容了：\n\n小结暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。\n没弄明白暂存区是怎么回事的童鞋，请向上滚动页面，再看一次。\n","categories":["git"]},{"title":"撤销修改","url":"/2020/04/30/git/%E6%92%A4%E9%94%80%E4%BF%AE%E6%94%B9/","content":"撤销修改\n自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行：\n$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN.\n\n在你准备提交前，一杯咖啡起了作用，你猛然发现了stupid boss可能会让你丢掉这个月的奖金！\n既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下：\n$ git statusOn branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)\tmodified:   readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)\n\n你可以发现，Git会告诉你，git checkout -- file可以丢弃工作区的修改：\n$ git checkout -- readme.txt\n\n命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：\n一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；\n一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n总之，就是让这个文件回到最近一次git commit或git add时的状态。\n现在，看看readme.txt的文件内容：\n$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.\n\n文件内容果然复原了。\ngit checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。\n现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了：\n$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN.$ git add readme.txt\n\n庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交：\n$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)\tmodified:   readme.txt\n\nGit同样告诉我们，用命令git reset HEAD 可以把暂存区的修改撤销掉（unstage），重新放回工作区：\n$ git reset HEAD readme.txtUnstaged changes after reset:M\treadme.txt\n\ngit reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。\n再用git status查看一下，现在暂存区是干净的，工作区有修改：\n$ git statusOn branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)\tmodified:   readme.txt\n\n还记得如何丢弃工作区的修改吗？\n$ git checkout -- readme.txt$ git statusOn branch masternothing to commit, working tree clean\n\n整个世界终于清静了！\n现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把stupid boss提交推送到远程版本库，你就真的惨了……\n小结又到了小结时间。\n场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。\n场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD ，就回到了场景1，第二步按场景1操作。\n场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。\n","categories":["git"]},{"title":"操作标签","url":"/2020/04/30/git/%E6%93%8D%E4%BD%9C%E6%A0%87%E7%AD%BE/","content":"操作标签\n如果标签打错了，也可以删除：\n$ git tag -d v0.1Deleted tag &#x27;v0.1&#x27; (was f15b0dd)\n\n因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。\n如果要推送某个标签到远程，使用命令git push origin ：\n$ git push origin v1.0Total 0 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git * [new tag]         v1.0 -&gt; v1.0\n\n或者，一次性推送全部尚未推送到远程的本地标签：\n$ git push origin --tagsTotal 0 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git * [new tag]         v0.9 -&gt; v0.9\n\n如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：\n$ git tag -d v0.9Deleted tag &#x27;v0.9&#x27; (was f52c633)\n\n然后，从远程删除。删除命令也是push，但是格式如下：\n$ git push origin :refs/tags/v0.9To github.com:michaelliao/learngit.git - [deleted]         v0.9\n\n要看看是否真的从远程库删除了标签，可以登陆GitHub查看。\n小结\n命令git push origin 可以推送一个本地标签；\n命令git push origin --tags可以推送全部未推送过的本地标签；\n命令git tag -d 可以删除一个本地标签；\n命令git push origin :refs/tags/可以删除一个远程标签。\n\n","categories":["git"]},{"title":"添加远程库","url":"/2020/04/30/git/%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/","content":"添加远程库\n现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。\n首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：\n在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：\n目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。\n现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：\n$ git remote add origin git@github.com:michaelliao/learngit.git\n\n请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。\n添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。\n下一步，就可以把本地库的所有内容推送到远程库上：\n$ git push -u origin masterCounting objects: 20, done.Delta compression using up to 4 threads.Compressing objects: 100% (15/15), done.Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.Total 20 (delta 5), reused 0 (delta 0)remote: Resolving deltas: 100% (5/5), done.To github.com:michaelliao/learngit.git * [new branch]      master -&gt; masterBranch &#x27;master&#x27; set up to track remote branch &#x27;master&#x27; from &#x27;origin&#x27;.\n\n把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：\n从现在起，只要本地作了提交，就可以通过命令：\n$ git push origin master\n\n把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！\nSSH警告当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：\nThe authenticity of host &#x27;github.com (xx.xx.xx.xx)&#x27; can&#x27;t be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)?\n\n这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。\nGit会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：\nWarning: Permanently added &#x27;github.com&#x27; (RSA) to the list of known hosts.\n\n这个警告只会出现一次，后面的操作就不会有任何警告了。\n如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。\n小结要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；\n关联后，使用命令git push -u origin master第一次推送master分支的所有内容；\n此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；\n分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！\n","categories":["git"]},{"title":"版本回退","url":"/2020/04/30/git/%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/","content":"\n现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：\nGit is a distributed version control system.Git is free software distributed under the GPL.\n\n然后尝试提交：\n$ git add readme.txt$ git commit -m &quot;append GPL&quot;[master 1094adb] append GPL 1 file changed, 1 insertion(+), 1 deletion(-)\n\n像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。\n现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了：\n版本1：wrote a readme file\nGit is a version control system.Git is free software.\n\n版本2：add distributed\nGit is a distributed version control system.Git is free software.\n\n版本3：append GPL\nGit is a distributed version control system.Git is free software distributed under the GPL.\n\n当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看：\n$ git logcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Fri May 18 21:06:15 2018 +0800    append GPLcommit e475afc93c209a690c39c13a46716e8fa000c366Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Fri May 18 21:03:36 2018 +0800    add distributedcommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Fri May 18 20:59:18 2018 +0800    wrote a readme file\n\ngit log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。\n如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数：\n$ git log --pretty=oneline1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPLe475afc93c209a690c39c13a46716e8fa000c366 add distributedeaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file\n\n需要友情提示的是，你看到的一大串类似1094adb...的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。\n每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：\n\n好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是add distributed的那个版本，怎么做呢？\n首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。\n现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令：\n$ git reset --hard HEAD^HEAD is now at e475afc add distributed\n\n--hard参数有啥意义？这个后面再讲，现在你先放心使用。\n看看readme.txt的内容是不是版本add distributed：\n$ cat readme.txtGit is a distributed version control system.Git is free software.\n\n果然被还原了。\n还可以继续回退到上一个版本wrote a readme file，不过且慢，然我们用git log再看看现在版本库的状态：\n$ git logcommit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Fri May 18 21:03:36 2018 +0800    add distributedcommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Fri May 18 20:59:18 2018 +0800    wrote a readme file\n\n最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？\n办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb...，于是就可以指定回到未来的某个版本：\n$ git reset --hard 1094aHEAD is now at 83b0afe append GPL\n\n版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。\n再小心翼翼地看看readme.txt的内容：\n$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.\n\n果然，我胡汉三又回来了。\nGit的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL：\n┌────┐│HEAD│└────┘   │   └──&gt; ○ append GPL        │        ○ add distributed        │        ○ wrote a readme file\n\n改为指向add distributed：\n┌────┐│HEAD│└────┘   │   │    ○ append GPL   │    │   └──&gt; ○ add distributed        │        ○ wrote a readme file\n\n然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。\n现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？\n在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：\n$ git refloge475afc HEAD@&#123;1&#125;: reset: moving to HEAD^1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPLe475afc HEAD@&#123;3&#125;: commit: add distributedeaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file\n\n终于舒了口气，从输出可知，append GPL的commit id是1094adb，现在，你又可以乘坐时光机回到未来了。\n小结现在总结一下：\n\nHEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。\n穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。\n要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。\n\n","categories":["git"]},{"title":"管理修改","url":"/2020/04/30/git/%E7%AE%A1%E7%90%86%E4%BF%AE%E6%94%B9/","content":"管理修改\n现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。\n你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。\n为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：\n$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes.\n\n然后，添加：\n$ git add readme.txt$ git status# On branch master# Changes to be committed:#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)##       modified:   readme.txt#\n\n然后，再修改readme.txt：\n$ cat readme.txt Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.\n\n提交：\n$ git commit -m &quot;git tracks changes&quot;[master 519219b] git tracks changes 1 file changed, 1 insertion(+)\n\n提交后，再看看状态：\n$ git statusOn branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)\tmodified:   readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)\n\n咦，怎么第二次的修改没有被提交？\n别激动，我们回顾一下操作过程：\n第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit\n你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。\n提交后，用git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别：\n$ git diff HEAD -- readme.txt diff --git a/readme.txt b/readme.txtindex 76d770f..a9c5755 100644--- a/readme.txt+++ b/readme.txt@@ -1,4 +1,4 @@ Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage.-Git tracks changes.+Git tracks changes of files.\n\n可见，第二次修改确实没有被提交。\n那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了：\n第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit\n好，现在，把第二次修改提交了，然后开始小结。\n小结现在，你又理解了Git是如何跟踪修改的，每次修改，如果不用git add到暂存区，那就不会加入到commit中。\n","categories":["git"]},{"title":"解决冲突","url":"/2020/04/30/git/%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81/","content":"解决冲突\n人生不如意之事十之八九，合并分支往往也不是一帆风顺的。\n准备新的feature1分支，继续我们的新分支开发：\n$ git checkout feature1Switched to a new branch &#x27;feature1&#x27;\n\n修改readme.txt最后一行，改为：\nCreating a new branch is quick AND simple.\n\n在feature1分支上提交：\n$ git add readme.txt$ git commit -m &quot;AND simple&quot;[feature1 14096d0] AND simple 1 file changed, 1 insertion(+), 1 deletion(-)\n\n切换到master分支：\n$ git checkout masterSwitched to branch &#x27;master&#x27;Your branch is ahead of &#x27;origin/master&#x27; by 1 commit.  (use &quot;git push&quot; to publish your local commits)\n\nGit还会自动提示我们当前master分支比远程的master分支要超前1个提交。\n在master分支上把readme.txt文件的最后一行改为：\nCreating a new branch is quick &amp; simple.\n\n提交：\n$ git add readme.txt $ git commit -m &quot;&amp; simple&quot;[master 5dc6824] &amp; simple 1 file changed, 1 insertion(+), 1 deletion(-)\n\n现在，master分支和feature1分支各自都分别有新的提交，变成了这样：\n\n这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：\n$ git merge feature1Auto-merging readme.txtCONFLICT (content): Merge conflict in readme.txtAutomatic merge failed; fix conflicts and then commit the result.\n\n果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件：\n$ git statusOn branch masterYour branch is ahead of &#x27;origin/master&#x27; by 2 commits.  (use &quot;git push&quot; to publish your local commits)You have unmerged paths.  (fix conflicts and run &quot;git commit&quot;)  (use &quot;git merge --abort&quot; to abort the merge)Unmerged paths:  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)\tboth modified:   readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)\n\n我们可以直接查看readme.txt的内容：\nGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1\n\nGit用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存：\nCreating a new branch is quick and simple.\n\n再提交：\n$ git add readme.txt $ git commit -m &quot;conflict fixed&quot;[master cf810e4] conflict fixed\n\n现在，master分支和feature1分支变成了下图所示：\n\n用带参数的git log也可以看到分支的合并情况：\n$ git log --graph --pretty=oneline --abbrev-commit*   cf810e4 (HEAD -&gt; master) conflict fixed|\\  | * 14096d0 (feature1) AND simple* | 5dc6824 &amp; simple|/  * b17d20e branch test* d46f35e (origin/master) remove test.txt* b84166e add test.txt* 519219b git tracks changes* e43a48b understand how stage works* 1094adb append GPL* e475afc add distributed* eaadf4e wrote a readme file\n\n最后，删除feature1分支：\n$ git branch -d feature1Deleted branch feature1 (was 14096d0).\n\n工作完成。\n小结当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。\n解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。\n用git log --graph命令可以看到分支合并图。\n","categories":["git"]},{"title":"markdown组件","url":"/2020/03/02/vue/component/","content":"傻瓜式markdown组件效果\ntemplate    &lt;script src=&quot;https://unpkg.com/marked@0.3.6&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/lodash@4.16.0&quot;&gt;&lt;/script&gt;&lt;div id=&quot;editor&quot;&gt;  &lt;textarea :value=&quot;input&quot; @input=&quot;update&quot;&gt;&lt;/textarea&gt;  &lt;div v-html=&quot;compiledMarkdown&quot;&gt;&lt;/div&gt;&lt;/div&gt;\nscriptnew Vue(&#123;  el: &#x27;#editor&#x27;,  data: &#123;    input: &#x27;# hello&#x27;  &#125;,  computed: &#123;    compiledMarkdown: function () &#123;      return marked(this.input, &#123; sanitize: true &#125;)    &#125;  &#125;,  methods: &#123;    update: _.debounce(function (e) &#123;      this.input = e.target.value    &#125;, 300)  &#125;&#125;)\ncsshtml, body, #editor &#123;  margin: 0;  height: 100%;  font-family: &#x27;Helvetica Neue&#x27;, Arial, sans-serif;  color: #333;&#125;textarea, #editor div &#123;  display: inline-block;  width: 49%;  height: 100%;  vertical-align: top;  box-sizing: border-box;  padding: 0 20px;&#125;textarea &#123;  border: none;  border-right: 1px solid #ccc;  resize: none;  outline: none;  background-color: #f6f6f6;  font-size: 14px;  font-family: &#x27;Monaco&#x27;, courier, monospace;  padding: 20px;&#125;code &#123;  color: #f66;&#125;","categories":["vue"]},{"title":"初识HTML","url":"/2018/07/02/html/%E5%88%9D%E5%A7%8BHTML/","content":"初识HTML本文主要的内容\n头标签\n\n\n排版标签： - &lt;p&gt;、 - &lt;div&gt;、 - &lt;span&gt;、 - &lt;br&gt;、 - &lt;hr&gt;、 - &lt;center&gt;、 - &lt;pre&gt; \n\n\n字体标记： - &lt;h1&gt;、 - &lt;font&gt;、 - &lt;b&gt;、 - &lt;u&gt;、 - &lt;sup&gt;、 - &lt;sub&gt;\n超链接： - &lt;a&gt;、\n图片标签： - &lt;img&gt;\n\n编辑器相关前端开发的编辑器软件，我首先推荐 VS Code，其次推荐Sublime Text。\n有人说 WebStorm 也不错？但真实情况是，自从VS Code 问世之后，用 WebStorm 的人越来越少了。\nVS Code 的使用详情请移步至：第一次使用VS Code时你应该知道的一切配置\nSublime Text 的使用详情请移步至：Sublime Text使用技巧\nHTML概述HTML的概念html 全称为 HyperText Markup Language，**译为超文本标记语言。**\nHTML 不是一种编程语言，是一种描述性的标记语言。\n作用：HTML是负责描述文档语义的语言。\n概念：超文本所谓的超文本，有两层含义：\n（1）图片、音频、视频、动画、多媒体等内容，成为超文本，因为它们超出了文本的限制。\n（2）不仅如此，它还可以从一个文件跳转到另一个文件，与世界各地主机的文件进行连接。即：超级链接文本。\n","categories":["html"]},{"title":"webpack","url":"/2020/06/13/webpack/README/","content":"webpack可以做的事情\n代码转换、文件优化、代码分割、模块合并、自动刷新、代码校验、自动发布\n\n最终目的\nwebpack的基本配置\nwebpack的高级配置\nwebpack的优化策略\nast抽象语法树\nwebpack的Tapable\n掌握webpack的流程 手写webpack\n手写webpack中常见的loader\n手写webpack中常见的plugin\n\n1. 安装webpack\nwebpack:提供了内置的东西 express plugin\nwebpack-cli: npx webpack\n服务: webpack-dev-server:启动服务 proxy beforeapp\n不会真正的打包文件, 只会在内存中打包 运行命令 npx webpack-dev-server\n\n\n\n2.配置文件let path = require(&quot;path&quot;);let HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);module.exports = &#123;//webpack 是node中的一个模块 CommonJs  devServer: &#123;//静态服务器的配置    port: 3000,    progress: true,//进度提哦啊    contentBase: &quot;./dist&quot;,//静态资源路径    compress:true//是否压缩Gzip  &#125;,  mode: &quot;production&quot;,//环境  entry: &quot;./src/index.js&quot;,  output: &#123;    filename: &quot;bundle[hash:8].js&quot;,//设置hash之后会解决浏览器缓存问题    path: path.resolve(__dirname, &quot;dist&quot;)//解析 会把相对路径解析成绝对路径  &#125;,  plugins: [    new HtmlWebpackPlugin(&#123;//打包的时候 自动把html打包到dist目录      template: &quot;./src/index.html&quot;,      filename: &quot;index.html&quot;,      minify:&#123;        removeAttributeQuotes:true,//去除双引号        collapseWhitespace:true//单行压缩      &#125;,      hash:true//是否加hash后缀    &#125;)  ]&#125;;\n\n\n\n思考1: 如何压缩html文件\n思考2: 如何实现命名的hash串\n\nplugins:[   new HtmlWebpackPlugin(&#123;     template: &#x27;./src/index.html&#x27;,     filename: &#x27;index.html&#x27;,     minify: &#123;       collapseWhitespace: true,       removeAttributeQuotes: true     &#125;,     hash: true   &#125;) ]\n\n2.1 修改样式2.2.1 loader配置如果直接插入css文件会报一个这样的错误\n\n解决:  下载两个loader\nmodule: &#123;//模块  rules: [//规则    &#123;      test: /\\.css$/,      use: [&#123;        loader: &#x27;style-loader&#x27;,//将css插入到head中        options: &#123;          insert: &#x27;top&#x27;//head/top foot        &#125;      &#125;, &#x27;css-loader&#x27;]    &#125;,    &#123;      test: /\\.scss$/,      use: [&#x27;style-loader&#x27;,&#x27;css-loader&#x27;, &#x27;sass-loader&#x27;]    &#125;  ],&#125;,\n\n2.1.1 分离css但是 此时 我们打包后发现 css是插入在js里面的\n\n为了解决这个问题 接下来我们引入 mini-css-extract-plugin这个插件\nlet MiniCssExtractPlugin require(&#x27;mini-css-extract-plugin&#x27;)\n\nrules: [     &#123;       test: /\\.css$/,       use: [&#123;         loader: MiniCssExtractPlugin.loader,       &#125;, &#x27;css-loader&#x27;]//loader顺序的规律     &#125;,     &#123;       test: /\\.(sc|sa)ss$/,       use: [&#123;         loader: MiniCssExtractPlugin.loader,       &#125;, &#x27;css-loader&#x27;, &#x27;sass-loader&#x27;]//loader顺序的规律     &#125;   ]\n\n\n\n\n当我们加入css3之后 新的问题出现了 没有前缀\n2.1.3 引入前缀此时 我们需要下载一个包autoprefixer以及一个loader文件postcss-loader\n&#123;        test: /\\.css$/,        use: [&#123;          loader: MiniCssExtractPlugin.loader,        &#125;, &#x27;css-loader&#x27;,&#x27;postcss-loader&#x27;]//loader顺序的规律      &#125;,\n\n\n\n\n创建一个配置文件 postcss.config.js\n\nmodule.exports = &#123;  plugins: [require(&#x27;autoprefixer&#x27;)]&#125;;\n\n再次打包\n\n需要注意的是 此设置项只能用早生产环境\nmode: &#39;production&#39;,\n2.1.4 压缩css文件如何压缩文件呢\n其中有个包 optimize-css-assets-webpack-plugin\n\n此包主要是用来压缩css的 但是 引入这个包后出现了js没被压缩的问题\n怎么解决呢\n按照官网配置需要使用TerserJSPlugin\nhttps://www.npmjs.com/package/mini-css-extract-plugin\noptimization: &#123;//webpack4.0之后新出的优化项配置  minimizer: [new TerserJSPlugin(&#123;&#125;), new OptimizeCssAssetsPlugin(&#123;&#125;)]&#125;,\n\nTerserJSPlugin具体参数查看这个\ninterface TerserPluginOptions &#123;        test?: string | RegExp | Array&lt;string | RegExp&gt;;        include?: string | RegExp | Array&lt;string | RegExp&gt;;        exclude?: string | RegExp | Array&lt;string | RegExp&gt;;        chunkFilter?: (chunk: webpack.compilation.Chunk) =&gt; boolean;        cache?: boolean | string;        cacheKeys?: (defaultCacheKeys: any, file: any) =&gt; object;        parallel?: boolean | number;        sourceMap?: boolean;        minify?: (file: any, sourceMap: any) =&gt; MinifyResult;        terserOptions?: MinifyOptions;        extractComments?: boolean        | string        | RegExp        | ExtractCommentFn        | ExtractCommentOptions;        warningsFilter?: (warning: any, source: any) =&gt; boolean;    &#125;\n\n2.2 处理js文件2.2.1 babel核心模块当我们尝试对写了es6语法的代码进行打包时候\n\n并没有变成es5\n接下来执行命令 babel\nyarn add babel-loader @babel/core @babel/preset-env\n\nbabel-loader : babel加载器\n@babel/core : babel的核心模块\n@babel/preset-env :  将es6转换成es5\n@babel/plugin-transform-runtime\n@babel/runtime\n@babel/polyfill\n\n&#123;        test: /\\.js$/,        use: [          &#123;            loader: &#x27;babel-loader&#x27;,            options: &#123;//预设                  presets: [&#x27;@babel/preset-env&#x27;]            &#125;          &#125;        ] &#125;\n\n接下来 就是见证奇迹的时刻\n\n2.2.2 处理箭头函数@babel/preset-env\n2.2.3 处理装饰器当我们添加装饰器 会有如下提示\n\n具体可以查看官网  https://babeljs.io/docs/en/babel-plugin-proposal-decorators \n&#123;       test: /\\.js$/,       use: [         &#123;           loader: &#x27;babel-loader&#x27;,           options: &#123;//预设             presets: [&#x27;@babel/preset-env&#x27;],             plugins:[               [&quot;@babel/plugin-proposal-decorators&quot;, &#123; &quot;legacy&quot;: true &#125;],               [&quot;@babel/plugin-proposal-class-properties&quot;, &#123; &quot;loose&quot; : true &#125;]             ]           &#125;         &#125;       ]     &#125;,\n\nindex.js\n@logclass A &#123;  a = 1;//es7 的语法(es6的变种语法)  // let a = new A() a.a = 1&#125;function log(target) &#123;  console.log(target,&#x27;21&#x27;);&#125;\n\n\n2.2.4 处理es7语法\n&#123;        test: /\\.js$/,        use: [          &#123;            loader: &#x27;babel-loader&#x27;,            options: &#123;//预设              presets: [&#x27;@babel/preset-env&#x27;],              plugins:[&#x27;@babel/plugin-proposal-class-properties&#x27;]            &#125;          &#125;        ]      &#125;\n\na.js\nclass B &#123;&#125;function* fnB() &#123;  yield 1;&#125;console.log(fnB().next());module.exports = &#x27;a&#x27;;\n\n接下来打包发现 每个文件都会打包一个_classCallCheck\n\n写了generator运行也会报错\n\n出现以上问题的原因是\n\n在webpack运行时不会自动检测哪些方法重用了\n\n一些es6的高级语法 比如generator和promise不会转换成es5\n\n\n\n根据官方文档https://babeljs.io/docs/en/babel-plugin-transform-runtime#docsNav\n需要下载两个包\nyarn add @babel/plugin-transform-runtime @babel/runtime -D\n执行npx webpack但是 报了一些警告\n\n&#123;       test: /\\.js$/,       use: [         &#123;           loader: &#x27;babel-loader&#x27;,           options: &#123;//预设             presets: [&#x27;@babel/preset-env&#x27;],             plugins: [               [&quot;@babel/plugin-proposal-decorators&quot;, &#123;&quot;legacy&quot;: true&#125;],               [&quot;@babel/plugin-proposal-class-properties&quot;, &#123;&quot;loose&quot;: true&#125;],               &quot;@babel/plugin-transform-runtime&quot;             ]           &#125;         &#125;       ],       include: path.resolve(__dirname, &#x27;src&#x27;),       exclude: /node_modules/     &#125;,\n\n\n\n2.2.5 处理全局变量的问题方法一 : 外置loader\nrequire(&#x27;expose-loader?$!jquery&#x27;);\n\n方法二 : 内置loader在每个模块都注入$\n// rules:&#123;//内置loader        test: require.resolve(&#x27;jquery&#x27;),        use: &#x27;expose-loader?$&#x27;      &#125;,          // plugins:    //提供者    new webpack.ProvidePlugin(&#123;      &quot;$&quot;: &quot;jquery&quot;    &#125;)\n\n\n\n优化:\n如果在html引入cdn路径并且在页面也 import $ from jquery 这就坏了, 即使引入cdn也会打包\n//排除之外  加入 在cdn引入了这个包 就不会打包这个包 externals: &#123;   &#x27;jquery&#x27;: &#x27;$ &#125;\n\n\n\n2.3 处理图片文件2.3.1 处理js中的图片index.jsimport logo from &#x27;./logo.png&#x27;;&lt;img src=logo/&gt;        webpack.config.js:&#123;    test: /\\.(png|jpg|gif)$/,      use: [&#123;        loader: &#x27;file-loader&#x27;,        options: &#123;        \tesModule: false,       &#125;,    &#125;&#125;\n\n\n\n2.3.2 处理css中图片文件因为css-loader中已经对图片做loader处理了 所以 只需要引入相应路径就行了\n2.3.3 处理html中的图片//1. 下载依赖yarn add html-withimg-plugin -D//2. 配置&#123;    test:/\\.html$/,    use:[&#x27;html-withimg-plugin&#x27;]    &#125;\n\n\n\n2.4 多入口多出口\n2.5 webpack小插件\nclean-webpack-plugin\n\nlet &#123;CleanWebpackPlugin&#125; = require(&#x27;clean-webpack-plugin&#x27;);//使用:plugins:[\tnew CleanWebpackPlugin()]\n\n\ncopy-webpack-plugin\n\nconst CopyPlugin = require(&#x27;copy-webpack-plugin&#x27;);module.exports = &#123;  plugins: [    new CopyPlugin([      &#123; from: &#x27;source&#x27;, to: &#x27;dest&#x27; &#125;,      &#123; from: &#x27;other&#x27;, to: &#x27;public&#x27; &#125;,    ]),  ],&#125;;\n\n\n\n2.6 resolve、分离2.6.1 resolveresolve:&#123;  modules:[path.resolve(__dirname,&#x27;node_modules&#x27;)],//只从当前这个node_modules查找相应的包  alise:&#123;//别名  &quot;bootstrapcss&quot;:&quot;bootstrap/dist/css/bootstrap.css&quot;\t&#125;,\textensions:[&#x27;js&#x27;,&#x27;jsx&#x27;,&#x27;vue&#x27;,&#x27;json&#x27;,&#x27;css&#x27;]&#125;\n\n2.6.2 分离文件 dev、 prod、baselet &#123;smart&#125; = require(&#x27;webpack-merge&#x27;)let base = require(&#x27;./webpack.config.js&#x27;)module.exports = smart(base,&#123;  mode:&#x27;production&#x27;&#125;)\n\n\n\n2.7 分离打包文件2.8 跨域\n方式一:在devServer中配置\n\ndevServer: &#123;  port: 8080,  host: &#x27;0.0.0.0&#x27;,  quiet: true,  proxy: &#123;    // &#x27;/api&#x27;: &#x27;http://127.0.0.1:3000&#x27;,    &#x27;/api&#x27;: &#123;      target: &#x27;http://127.0.0.1:3000&#x27;,      pathRewrite:&#123;        &#x27;^/api&#x27;: &#x27;&#x27;      &#125;    &#125;,  &#125;,  before(app) &#123;    //app就是express对象    app.get(&#x27;/list&#x27;, function (req, res) &#123;      res.send(&#123;code: 1, msg: &#x27;hello&#x27;&#125;);    &#125;);  &#125;&#125;,\n\n\n方式二 : 在服务端配置(node/express)\n\n//1: npm i webpack-dev-middleware\n\nlet middleDevWebpack = require(&#x27;webpack-dev-middleware&#x27;)let config = require(&#x27;./webpack.config.js&#x27;)app.use(middleDevWebpack(config))\n\n2.9 懒加载和热更新实时监听\n\n热更新\ndevServer:&#123;  hot:true,  quite:true//安静启动&#125;\n实时监听\nwatch:true,wathcOptions:&#123;  poll:1000,    aggregateTimeout:500,    ignore:/note_modules/&#125;\n\n3. webpack优化打包优化，可以从几个出发点点\n\n打包体积\n\n加载速度\n\n打包速度\n\nwebpack自带优化\n\ntree-sharking  : import 把没用的代码自动删除掉\nscope-hoisting : 作用域提升\n\n\n优化网络解析时长和执行时长\n\n添加DNS预解析\n延时执行影响页面渲染的代码\n\n\n优化webpack产出\n\n优化代码重复打包\n去掉不必要的import\nbabel-preset-env 和 autoprefix 配置优化\nwebpack runtime文件inline\n去除不必要的async语句\n优化第三方依赖\nlodash按需引入\n\n\nwebpack 知识点\n\nhash、contenthash、chunkhash的区别\nsplitChunks详解\n\n\n必杀技–动态链接库\n\n多进程打包之HappyPack\n\n提取公共代码\n\n\n3.1 webpack自带优化\ntree-sharkingTree-shaking主要依赖于ES6的模块化import和export，我们都知道ES6的module只能是顶层出现，和运行时无关，不能运行时加载，Tree-shaking主要就是依靠这个基础进行静态分析，不执行代码就从字面量对代码进行分析。如果是require，需要执行后才知道有没有引用，就无法进行Tree-shaking。\nscope-hoisting由于 Scope Hoisting 需要分析出模块之间的依赖关系，因此源码必须采用 ES6 模块化语句，不然将无法生效。原因与tree-sharking相似作用:“作用域提升”，它可以让 webpack 打包出来的代码文件更小，运行更快。代码体积更小，因为函数声明语句会产生大量代码，导致包体积增大（模块越多越明显）；代码在运行时因为创建的函数作用域更少，内存开销也随之变小。\n\n3.2 多线程打包需要用到happypack实现多线程打包\n注意: 如果体积较小会使打包时间更长\n第一步:下载npm install happypack --save-dev\n\nconst HappyPack = require(&#x27;happypack&#x27;);module.exports = &#123;    ...&#125;\n\n第二步: 将常用的 loader 替换为 happypack/loaderconst HappyPack = require(&#x27;happypack&#x27;);module.exports = &#123;    ...    module: &#123;        rules: [            test: /\\.js$/,            // use: [&#x27;babel-loader?cacheDirectory&#x27;] 之前是使用这种方式直接使用 loader            // 现在用下面的方式替换成 happypack/loader，并使用 id 指定创建的 HappyPack 插件            use: [&#x27;happypack/loader?id=babel&#x27;],            // 排除 node_modules 目录下的文件            exclude: /node_modules/        ]    &#125;&#125;\n\n三、创建 HappyPack 插件module.exports = &#123;    ...    module: &#123;        rules: [            test: /\\.js$/,            // use: [&#x27;babel-loader?cacheDirectory&#x27;] 之前是使用这种方式直接使用 loader            // 现在用下面的方式替换成 happypack/loader，并使用 id 指定创建的 HappyPack 插件            use: [&#x27;happypack/loader?id=babel&#x27;],            // 排除 node_modules 目录下的文件            exclude: /node_modules/        ]    &#125;,    plugins: [        ...,        new HappyPack(&#123;            /*             * 必须配置             */            // id 标识符，要和 rules 中指定的 id 对应起来            id: &#x27;babel&#x27;,            // 需要使用的 loader，用法和 rules 中 Loader 配置一样            // 可以直接是字符串，也可以是对象形式            loaders: [&#x27;babel-loader?cacheDirectory&#x27;]        &#125;)    ]&#125;\n\n3.3 关于语言包的打包有些包自带语言包，有时候不需要把所有的语言包跟着打包比如 moment，那么我们就需要把这个包特殊对待，\n主要是通过webpack自导的IgnorePlugin\nsrc下某.js\nimport moment from &#x27;moment&#x27;;import &#x27;moment/locale/zh-cn&#x27;;moment.locale(&#x27;zh-cn&#x27;);let r = moment().endOf(&#x27;day&#x27;).fromNow();console.log(r);\n\nwebpack.config.js\nplugins: [  ...\tnew webpack.IgnorePlugin(/\\.\\/locale/,/moment/),]\n\n3.3 不打包某个文件有些文件我们不希望打包，比如已经在cdn中引入了的文件，此时要用externals进行配置\nmodules:&#123;  noParse:/jquery/, \t...&#125;plugins: [  ...\tnew webpack.ProvidePlugin(&#123;      &#x27;$&#x27;: &#x27;jquery&#x27;  &#125;),] //忽略打包的文件externals:&#123;  &#x27;jquery&#x27;: &#x27;$&#x27;&#125;\n\n\n\n3.4 webpack必杀技 : 动态链接库\n什么是动态链接库: 用dll链接的方式提取固定的js文件，并链接这个js文件\n当我们引入一个js文件的时候，这个js文件比较大，那我们是否可以单独打包，发布到cdn上，直接引用\n\n比如 当我们想要把react打包的时候，希望将react和reactdom放到一个js文件打包的时候 不打包这两个文件，而是直接引用js的cdn路径\n\n\n新建一个webpack的js配置文件\nwebpack.react.js\nvar path = require(&#x27;path&#x27;);let webpack = require(&quot;webpack&quot;);module.exports = &#123;  mode: &#x27;development&#x27;,  entry: &#123;    react: [&#x27;react&#x27;, &#x27;react-dom&#x27;]  &#125;,  output:&#123;    filename: &#x27;_dll_[name].js&#x27;,    path: path.resolve(__dirname, &#x27;dist&#x27;),    library: &#x27;_dll_[name]&#x27;,    //  &quot;var&quot; | &quot;assign&quot; | &quot;this&quot; | &quot;window&quot; | &quot;self&quot; | &quot;global&quot; | &quot;commonjs&quot; | &quot;commonjs2&quot; | &quot;commonjs-module&quot; | &quot;amd&quot; | &quot;amd-require&quot; | &quot;umd&quot; | &quot;umd2&quot; | &quot;jsonp&quot; | &quot;system&quot;    // libraryTarget: &#x27;commonjs2&#x27;//默认 var  &#125;,  plugins: [    new webpack.DllPlugin(&#123;      name: &#x27;_dll_[name]&#x27;,      path: path.resolve(__dirname, &#x27;dist&#x27;, &#x27;manifest.json&#x27;)    &#125;)  ]&#125;;\n\nnpx webpack --config webpack.react.js\n\n\n\n此时就会生成一个manifest.json文件\n\n最后 在webpack.prod.config.js线上配置文件中引入插件\nnew webpack.DllReferencePlugin(&#123;  manifest: path.resolve(__dirname, &#x27;dist&#x27;, &#x27;manifest.json&#x27;)&#125;)\n\n3.5 抽离公共代码块optimization: &#123;//webpack4.0之后出现的优化项    minimizer: [new TerserPlugin(&#123;&#125;), new OptimizeCssAssetsWebpackPlugin(&#123;&#125;)],//压缩css    //缺陷 可以压缩css 但是 js压缩又出现了问题    splitChunks:&#123;//分割代码块      cacheGroups:&#123;//缓存组        common:&#123;//公共的逻辑          chunks: &#x27;initial&#x27;,//从入口文件开始查找          minSize: 0,//最小分包体积          minChunks: 2,//        &#125;,        vendor:&#123;          priority: 1,          test:/node_modules/,          chunks: &#x27;initial&#x27;,          minSize: 0,          minChunks: 2        &#125;      &#125;    &#125;  &#125;,\n\n4. webpack打包原理webpack 构建流程Webpack 的运行流程是一个串行的过程,从启动到结束会依次执行以下流程 :\n\n初始化参数：从配置文件和 Shell 语句中读取与合并参数,得出最终的参数。\n开始编译：用上一步得到的参数初始化 Compiler 对象,加载所有配置的插件,执行对象的 run 方法开始执行编译。\n确定入口：根据配置中的 entry 找出所有的入口文件。\n编译模块：从入口文件出发,调用所有配置的 Loader 对模块进行翻译,再找出该模块依赖的模块,再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。\n完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后,得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。\n输出资源：根据入口和模块之间的依赖关系,组装成一个个包含多个模块的 Chunk,再把每个 Chunk 转换成一个单独的文件加入到输出列表,这步是可以修改输出内容的最后机会。\n输出完成：在确定好输出内容后,根据配置确定输出的路径和文件名,把文件内容写入到文件系统。\n\n在以上过程中,Webpack 会在特定的时间点广播出特定的事件,插件在监听到感兴趣的事件后会执行特定的逻辑,并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。\n实践加深理解,撸一个简易 webpack1. 定义 Compiler 类class Compiler &#123;  constructor(options) &#123;    // webpack 配置    const &#123; entry, output &#125; = options    // 入口    this.entry = entry    // 出口    this.output = output    // 模块    this.modules = []  &#125;  // 构建启动  run() &#123;&#125;  // 重写 require函数,输出bundle  generate() &#123;&#125;&#125;\n\n2. 解析入口文件,获取 AST我们这里使用@babel/parser,这是 babel7 的工具,来帮助我们分析内部的语法,包括 es6,返回一个 AST 抽象语法树。\n// webpack.config.jsconst path = require(&#x27;path&#x27;)module.exports = &#123;  entry: &#x27;./src/index.js&#x27;,  output: &#123;    path: path.resolve(__dirname, &#x27;./dist&#x27;),    filename: &#x27;main.js&#x27;  &#125;&#125;//const fs = require(&#x27;fs&#x27;)const parser = require(&#x27;@babel/parser&#x27;)const options = require(&#x27;./webpack.config&#x27;)const Parser = &#123;  getAst: path =&gt; &#123;    // 读取入口文件    const content = fs.readFileSync(path, &#x27;utf-8&#x27;)    // 将文件内容转为AST抽象语法树    return parser.parse(content, &#123;      sourceType: &#x27;module&#x27;    &#125;)  &#125;&#125;class Compiler &#123;  constructor(options) &#123;    // webpack 配置    const &#123; entry, output &#125; = options    // 入口    this.entry = entry    // 出口    this.output = output    // 模块    this.modules = []  &#125;  // 构建启动  run() &#123;    const ast = Parser.getAst(this.entry)  &#125;  // 重写 require函数,输出bundle  generate() &#123;&#125;&#125;new Compiler(options).run()\n\n3. 找出所有依赖模块Babel 提供了@babel/traverse(遍历)方法维护这 AST 树的整体状态,我们这里使用它来帮我们找出依赖模块。\nconst fs = require(&#x27;fs&#x27;)const path = require(&#x27;path&#x27;)const options = require(&#x27;./webpack.config&#x27;)const parser = require(&#x27;@babel/parser&#x27;)const traverse = require(&#x27;@babel/traverse&#x27;).defaultconst Parser = &#123;  getAst: path =&gt; &#123;    // 读取入口文件    const content = fs.readFileSync(path, &#x27;utf-8&#x27;)    // 将文件内容转为AST抽象语法树    return parser.parse(content, &#123;      sourceType: &#x27;module&#x27;    &#125;)  &#125;,  getDependecies: (ast, filename) =&gt; &#123;    const dependecies = &#123;&#125;    // 遍历所有的 import 模块,存入dependecies    traverse(ast, &#123;      // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句)      ImportDeclaration(&#123; node &#125;) &#123;        const dirname = path.dirname(filename)        // 保存依赖模块路径,之后生成依赖关系图需要用到        const filepath = &#x27;./&#x27; + path.join(dirname, node.source.value)        dependecies[node.source.value] = filepath      &#125;    &#125;)    return dependecies  &#125;&#125;class Compiler &#123;  constructor(options) &#123;    // webpack 配置    const &#123; entry, output &#125; = options    // 入口    this.entry = entry    // 出口    this.output = output    // 模块    this.modules = []  &#125;  // 构建启动  run() &#123;    const &#123; getAst, getDependecies &#125; = Parser    const ast = getAst(this.entry)    const dependecies = getDependecies(ast, this.entry)  &#125;  // 重写 require函数,输出bundle  generate() &#123;&#125;&#125;new Compiler(options).run()\n\n4. AST 转换为 code将 AST 语法树转换为浏览器可执行代码,我们这里使用@babel/core 和 @babel/preset-env。\nconst fs = require(&#x27;fs&#x27;)const path = require(&#x27;path&#x27;)const options = require(&#x27;./webpack.config&#x27;)const parser = require(&#x27;@babel/parser&#x27;)const traverse = require(&#x27;@babel/traverse&#x27;).defaultconst &#123; transformFromAst &#125; = require(&#x27;@babel/core&#x27;)const Parser = &#123;  getAst: path =&gt; &#123;    // 读取入口文件    const content = fs.readFileSync(path, &#x27;utf-8&#x27;)    // 将文件内容转为AST抽象语法树    return parser.parse(content, &#123;      sourceType: &#x27;module&#x27;    &#125;)  &#125;,  getDependecies: (ast, filename) =&gt; &#123;    const dependecies = &#123;&#125;    // 遍历所有的 import 模块,存入dependecies    traverse(ast, &#123;      // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句)      ImportDeclaration(&#123; node &#125;) &#123;        const dirname = path.dirname(filename)        // 保存依赖模块路径,之后生成依赖关系图需要用到        const filepath = &#x27;./&#x27; + path.join(dirname, node.source.value)        dependecies[node.source.value] = filepath      &#125;    &#125;)    return dependecies  &#125;,  getCode: ast =&gt; &#123;    // AST转换为code    const &#123; code &#125; = transformFromAst(ast, null, &#123;      presets: [&#x27;@babel/preset-env&#x27;]    &#125;)    return code  &#125;&#125;class Compiler &#123;  constructor(options) &#123;    // webpack 配置    const &#123; entry, output &#125; = options    // 入口    this.entry = entry    // 出口    this.output = output    // 模块    this.modules = []  &#125;  // 构建启动  run() &#123;    const &#123; getAst, getDependecies, getCode &#125; = Parser    const ast = getAst(this.entry)    const dependecies = getDependecies(ast, this.entry)    const code = getCode(ast)  &#125;  // 重写 require函数,输出bundle  generate() &#123;&#125;&#125;new Compiler(options).run()\n\n5. 递归解析所有依赖项,生成依赖关系图const fs = require(&#x27;fs&#x27;)const path = require(&#x27;path&#x27;)const options = require(&#x27;./webpack.config&#x27;)const parser = require(&#x27;@babel/parser&#x27;)const traverse = require(&#x27;@babel/traverse&#x27;).defaultconst &#123; transformFromAst &#125; = require(&#x27;@babel/core&#x27;)const Parser = &#123;  getAst: path =&gt; &#123;    // 读取入口文件    const content = fs.readFileSync(path, &#x27;utf-8&#x27;)    // 将文件内容转为AST抽象语法树    return parser.parse(content, &#123;      sourceType: &#x27;module&#x27;    &#125;)  &#125;,  getDependecies: (ast, filename) =&gt; &#123;    const dependecies = &#123;&#125;    // 遍历所有的 import 模块,存入dependecies    traverse(ast, &#123;      // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句)      ImportDeclaration(&#123; node &#125;) &#123;        const dirname = path.dirname(filename)        // 保存依赖模块路径,之后生成依赖关系图需要用到        const filepath = &#x27;./&#x27; + path.join(dirname, node.source.value)        dependecies[node.source.value] = filepath      &#125;    &#125;)    return dependecies  &#125;,  getCode: ast =&gt; &#123;    // AST转换为code    const &#123; code &#125; = transformFromAst(ast, null, &#123;      presets: [&#x27;@babel/preset-env&#x27;]    &#125;)    return code  &#125;&#125;class Compiler &#123;  constructor(options) &#123;    // webpack 配置    const &#123; entry, output &#125; = options    // 入口    this.entry = entry    // 出口    this.output = output    // 模块    this.modules = []  &#125;  // 构建启动  run() &#123;    // 解析入口文件    const info = this.build(this.entry)    this.modules.push(info)    this.modules.forEach((&#123; dependecies &#125;) =&gt; &#123;      // 判断有依赖对象,递归解析所有依赖项      if (dependecies) &#123;        for (const dependency in dependecies) &#123;          this.modules.push(this.build(dependecies[dependency]))        &#125;      &#125;    &#125;)    // 生成依赖关系图    const dependencyGraph = this.modules.reduce(      (graph, item) =&gt; (&#123;        ...graph,        // 使用文件路径作为每个模块的唯一标识符,保存对应模块的依赖对象和文件内容        [item.filename]: &#123;          dependecies: item.dependecies,          code: item.code        &#125;      &#125;),      &#123;&#125;    )  &#125;  build(filename) &#123;    const &#123; getAst, getDependecies, getCode &#125; = Parser    const ast = getAst(filename)    const dependecies = getDependecies(ast, filename)    const code = getCode(ast)    return &#123;      // 文件路径,可以作为每个模块的唯一标识符      filename,      // 依赖对象,保存着依赖模块路径      dependecies,      // 文件内容      code    &#125;  &#125;  // 重写 require函数,输出bundle  generate() &#123;&#125;&#125;new Compiler(options).run()\n\n6. 重写 require 函数,输出 bundleconst fs = require(&#x27;fs&#x27;)const path = require(&#x27;path&#x27;)const options = require(&#x27;./webpack.config&#x27;)const parser = require(&#x27;@babel/parser&#x27;)const traverse = require(&#x27;@babel/traverse&#x27;).defaultconst &#123; transformFromAst &#125; = require(&#x27;@babel/core&#x27;)const Parser = &#123;  getAst: path =&gt; &#123;    // 读取入口文件    const content = fs.readFileSync(path, &#x27;utf-8&#x27;)    // 将文件内容转为AST抽象语法树    return parser.parse(content, &#123;      sourceType: &#x27;module&#x27;    &#125;)  &#125;,  getDependecies: (ast, filename) =&gt; &#123;    const dependecies = &#123;&#125;    // 遍历所有的 import 模块,存入dependecies    traverse(ast, &#123;      // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句)      ImportDeclaration(&#123; node &#125;) &#123;        const dirname = path.dirname(filename)        // 保存依赖模块路径,之后生成依赖关系图需要用到        const filepath = &#x27;./&#x27; + path.join(dirname, node.source.value)        dependecies[node.source.value] = filepath      &#125;    &#125;)    return dependecies  &#125;,  getCode: ast =&gt; &#123;    // AST转换为code    const &#123; code &#125; = transformFromAst(ast, null, &#123;      presets: [&#x27;@babel/preset-env&#x27;]    &#125;)    return code  &#125;&#125;class Compiler &#123;  constructor(options) &#123;    // webpack 配置    const &#123; entry, output &#125; = options    // 入口    this.entry = entry    // 出口    this.output = output    // 模块    this.modules = []  &#125;  // 构建启动  run() &#123;    // 解析入口文件    const info = this.build(this.entry)    this.modules.push(info)    this.modules.forEach((&#123; dependecies &#125;) =&gt; &#123;      // 判断有依赖对象,递归解析所有依赖项      if (dependecies) &#123;        for (const dependency in dependecies) &#123;          this.modules.push(this.build(dependecies[dependency]))        &#125;      &#125;    &#125;)    // 生成依赖关系图    const dependencyGraph = this.modules.reduce(      (graph, item) =&gt; (&#123;        ...graph,        // 使用文件路径作为每个模块的唯一标识符,保存对应模块的依赖对象和文件内容        [item.filename]: &#123;          dependecies: item.dependecies,          code: item.code        &#125;      &#125;),      &#123;&#125;    )    this.generate(dependencyGraph)  &#125;  build(filename) &#123;    const &#123; getAst, getDependecies, getCode &#125; = Parser    const ast = getAst(filename)    const dependecies = getDependecies(ast, filename)    const code = getCode(ast)    return &#123;      // 文件路径,可以作为每个模块的唯一标识符      filename,      // 依赖对象,保存着依赖模块路径      dependecies,      // 文件内容      code    &#125;  &#125;  // 重写 require函数 (浏览器不能识别commonjs语法),输出bundle  generate(code) &#123;    // 输出文件路径    const filePath = path.join(this.output.path, this.output.filename)    // 懵逼了吗? 没事,下一节我们捋一捋    const bundle = `(function(graph)&#123;      function require(module)&#123;        function localRequire(relativePath)&#123;          return require(graph[module].dependecies[relativePath])        &#125;        var exports = &#123;&#125;;        (function(require,exports,code)&#123;          eval(code)        &#125;)(localRequire,exports,graph[module].code);        return exports;      &#125;      require(&#x27;$&#123;this.entry&#125;&#x27;)    &#125;)($&#123;JSON.stringify(code)&#125;)`    // 把文件内容写入到文件系统    fs.writeFileSync(filePath, bundle, &#x27;utf-8&#x27;)  &#125;&#125;new Compiler(options).run()\n\n7. 看完这节,彻底搞懂 bundle 实现我们通过下面的例子来进行讲解,先死亡凝视 30 秒\n;(function(graph) &#123;  function require(moduleId) &#123;    function localRequire(relativePath) &#123;      return require(graph[moduleId].dependecies[relativePath])    &#125;    var exports = &#123;&#125;    ;(function(require, exports, code) &#123;      eval(code)    &#125;)(localRequire, exports, graph[moduleId].code)    return exports  &#125;  require(&#x27;./src/index.js&#x27;)&#125;)(&#123;  &#x27;./src/index.js&#x27;: &#123;    dependecies: &#123; &#x27;./hello.js&#x27;: &#x27;./src/hello.js&#x27; &#125;,    code: &#x27;&quot;use strict&quot;;\\n\\nvar _hello = require(&quot;./hello.js&quot;);\\n\\ndocument.write((0, _hello.say)(&quot;webpack&quot;));&#x27;  &#125;,  &#x27;./src/hello.js&#x27;: &#123;    dependecies: &#123;&#125;,    code:      &#x27;&quot;use strict&quot;;\\n\\nObject.defineProperty(exports, &quot;__esModule&quot;, &#123;\\n  value: true\\n&#125;);\\nexports.say = say;\\n\\nfunction say(name) &#123;\\n  return &quot;hello &quot;.concat(name);\\n&#125;&#x27;  &#125;&#125;)\n\nstep 1 : 从入口文件开始执行// 定义一个立即执行函数,传入生成的依赖关系图;(function(graph) &#123;  // 重写require函数  function require(moduleId) &#123;    console.log(moduleId) // ./src/index.js  &#125;  // 从入口文件开始执行  require(&#x27;./src/index.js&#x27;)&#125;)(&#123;  &#x27;./src/index.js&#x27;: &#123;    dependecies: &#123; &#x27;./hello.js&#x27;: &#x27;./src/hello.js&#x27; &#125;,    code: &#x27;&quot;use strict&quot;;\\n\\nvar _hello = require(&quot;./hello.js&quot;);\\n\\ndocument.write((0, _hello.say)(&quot;webpack&quot;));&#x27;  &#125;,  &#x27;./src/hello.js&#x27;: &#123;    dependecies: &#123;&#125;,    code:      &#x27;&quot;use strict&quot;;\\n\\nObject.defineProperty(exports, &quot;__esModule&quot;, &#123;\\n  value: true\\n&#125;);\\nexports.say = say;\\n\\nfunction say(name) &#123;\\n  return &quot;hello &quot;.concat(name);\\n&#125;&#x27;  &#125;&#125;)\n\nstep 2 : 使用 eval 执行代码// 定义一个立即执行函数,传入生成的依赖关系图;(function(graph) &#123;  // 重写require函数  function require(moduleId) &#123;    ;(function(code) &#123;      console.log(code) // &quot;use strict&quot;;\\n\\nvar _hello = require(&quot;./hello.js&quot;);\\n\\ndocument.write((0, _hello.say)(&quot;webpack&quot;));      eval(code) // Uncaught TypeError: Cannot read property &#x27;code&#x27; of undefined    &#125;)(graph[moduleId].code)  &#125;  // 从入口文件开始执行  require(&#x27;./src/index.js&#x27;)&#125;)(&#123;  &#x27;./src/index.js&#x27;: &#123;    dependecies: &#123; &#x27;./hello.js&#x27;: &#x27;./src/hello.js&#x27; &#125;,    code: &#x27;&quot;use strict&quot;;\\n\\nvar _hello = require(&quot;./hello.js&quot;);\\n\\ndocument.write((0, _hello.say)(&quot;webpack&quot;));&#x27;  &#125;,  &#x27;./src/hello.js&#x27;: &#123;    dependecies: &#123;&#125;,    code:      &#x27;&quot;use strict&quot;;\\n\\nObject.defineProperty(exports, &quot;__esModule&quot;, &#123;\\n  value: true\\n&#125;);\\nexports.say = say;\\n\\nfunction say(name) &#123;\\n  return &quot;hello &quot;.concat(name);\\n&#125;&#x27;  &#125;&#125;)\n\n可以看到,我们在执行”./src/index.js”文件代码的时候报错了,这是因为 index.js 里引用依赖 hello.js,而我们没有对依赖进行处理,接下来我们对依赖引用进行处理。\nstep 3 : 依赖对象寻址映射,获取 exports 对象// 定义一个立即执行函数,传入生成的依赖关系图;(function(graph) &#123;  // 重写require函数  function require(moduleId) &#123;    // 找到对应moduleId的依赖对象,调用require函数,eval执行,拿到exports对象    function localRequire(relativePath) &#123;      return require(graph[moduleId].dependecies[relativePath]) // &#123;__esModule: true, say: ƒ say(name)&#125;    &#125;    // 定义exports对象    var exports = &#123;&#125;    ;(function(require, exports, code) &#123;      // commonjs语法使用module.exports暴露实现,我们传入的exports对象会捕获依赖对象(hello.js)暴露的实现(exports.say = say)并写入      eval(code)    &#125;)(localRequire, exports, graph[moduleId].code)    // 暴露exports对象,即暴露依赖对象对应的实现    return exports  &#125;  // 从入口文件开始执行  require(&#x27;./src/index.js&#x27;)&#125;)(&#123;  &#x27;./src/index.js&#x27;: &#123;    dependecies: &#123; &#x27;./hello.js&#x27;: &#x27;./src/hello.js&#x27; &#125;,    code: &#x27;&quot;use strict&quot;;\\n\\nvar _hello = require(&quot;./hello.js&quot;);\\n\\ndocument.write((0, _hello.say)(&quot;webpack&quot;));&#x27;  &#125;,  &#x27;./src/hello.js&#x27;: &#123;    dependecies: &#123;&#125;,    code:      &#x27;&quot;use strict&quot;;\\n\\nObject.defineProperty(exports, &quot;__esModule&quot;, &#123;\\n  value: true\\n&#125;);\\nexports.say = say;\\n\\nfunction say(name) &#123;\\n  return &quot;hello &quot;.concat(name);\\n&#125;&#x27;  &#125;&#125;)\n\n这下应该明白了吧 ~ 可以直接复制上面代码到控制台输出哦~\n完整代码地址戳我 👈\n总结\nWebpack 是一个庞大的 Node.js 应用,如果你阅读过它的源码,你会发现实现一个完整的 Webpack 需要编写非常多的代码。 但你无需了解所有的细节,只需了解其整体架构和部分细节即可。\n对 Webpack 的使用者来说,它是一个简单强大的工具； 对 Webpack 的开发者来说,它是一个扩展性的高系统。\nWebpack 之所以能成功,在于它把复杂的实现隐藏了起来,给用户暴露出的只是一个简单的工具,让用户能快速达成目的。 同时整体架构设计合理,扩展性高,开发扩展难度不高,通过社区补足了大量缺失的功能,让 Webpack 几乎能胜任任何场景。\n\n","categories":["webpack"]},{"title":"垂直居中的方法","url":"/2018/10/04/css/all/","content":"垂直居中的方法\n设置子元素和父元素的行高一样\n子元素设置为行内块，再加上vertical-align:middle\n已知父元素的高度，子元素相对定位，通过transfrom:translateY(-50%)\n不知道父元素的高度，子绝父相，子元素top:50% transfrom:translateY(-50%)\n创建一个隐藏节点，让隐藏的节点height为剩余高度的一半\n给父元素display:table，子元素display:table-cell vertical-align:middle7: 给父元素添加伪类\n弹性盒子 父级display:flex 子元素 align-self:center\n\n","categories":["css"]},{"title":"元素水平居中的方法","url":"/2018/10/04/css/center/","content":"元素水平居中的方法\n子父元素宽度固定，子元素设置margin 0 auto，并且子元素不能设置浮动，否则居中失效\n\n子父元素宽度固定，父元素设施text-align:Center，子元素设置display:inline-block并且子元素不能设置浮动，否则居中失效\n\n子元素相对于父元素绝对定位，子元素top left设置50%，子元素margin-top和margin-left减去各自高的一半\n\n子元素相对于父元素绝对定位，子元素 上下左右全为0 然后设置子元素 marign:0 auto\n\n父元素设置display:table-cell vertical-align:middle 子元素设置marign:0 auto\n\n子元素相对定位 子元素top left值为50% transfrom:translate(-50%-50%)\n\n子元素相对父元素绝对定位 子元素top left值为50% transfrom:translate(-50%,-50%)\n\n父元素设置弹性盒子：\n    Display:flex ;Justify-content：center   Align-item:center\n\n","categories":["css"]},{"title":"用css动画代替js动画的好处","url":"/2018/10/13/css/cssanimation/","content":"用css动画代替js动画的好处导致js效率低下的两个原因：操作DOM和使用页面动画在频繁的操作DOM和CSS时，浏览器会不停的执行重排和重绘，在pc浏览器因为浏览器的内存比较大，用户几乎看不见页面动画产生的重绘和重排在移动设备上分配给浏览器的内存没有PC浏览器的内存客观\n用CSS3动画代替JS模拟动画的好处：1. 不占用JS主线程\n2. 可以利用硬件加速\n3. 浏览器可对动画做优化（元素不可见时不动画，减少FPS的影响）\n\n坏处：浏览器对渲染的批量异步处理让动画难以控制\n\n解决方法：强制同步$.fn.repaint=function()&#123;    this.each(function(item)&#123;        return item.clientHeight    &#125;)&#125;\n\nCSS动画和JS模拟动画有以下区别：1. CSS3D动画在JS中无法实现\n2. CSS2D矩阵动画效率高于JS用margin和left top模拟的矩阵动画\n3. CSS3其他常规动画属性的效率低于JS模拟的动画\n常规的动画：height width,opacity,border-width,color …\n\n","categories":["css"]},{"title":"H5的新特性","url":"/2018/07/03/html/H5new/","content":"H5有哪些新特性HTML5有哪些新特性，移除了哪些元素？如何处理HTML=5新标签的浏览器兼容问题？如何区分HTML和HTML5?HTML5现在已经不是SGML的子集，主要是关于图像、位置、储存、多任务的等功能的增加\n绘画：绘画canvas\n\n音频视频：用于媒介回放的video和audio元素\n\n存储：本地离线存储localStorage长期存储数据 浏览器关闭后数据不会丢失\nsessionStorage的数据在浏览器关闭后自动删除\n\n语义化标签：语意化更好的内容元素：- `article`、    - `footer`、    - `header`、    - `nav`、    - `section`、\n\n表单控件：\ncalender、    - date、    - time、    - email、    - url、- search新的技术：\nwebsoket、    - webworker、    - Geolocation移除的元素：纯表现的元素： - basefont、    - big、    - center、    - font、    - s、 - strike、- tt、- u对可用性产生的负面影响的元素：\n\n\nfarme、- frameset、- noframes支持HTML5新标签： IE8/IE7/IE6支持document.creatElement()的方法产生的标签 可以利用这一特性让这些浏览器支持HTML5新标签如何区分HTML5：DOCTYPE声明\\新增的结构元素\\功能元素\n\n","categories":["html"]},{"title":"高度塌陷","url":"/2018/10/20/css/height/","content":"高度塌陷概念    当所有子元素浮动的时候，且父级元素没有设置高度的时候，这时候父元素就会产生高度塌陷\n\n清除浮动的方式1. 给父元素单独设置高度\n    优点：快速简单 代码少，\n    缺点：无法进行响应式布局\n2. 父级设置 overflow：hidden；zoom：1(针对IE6的兼容)\n    优点：简单快速，代码少，兼容性高\n    缺点：超出部分隐藏，布局时候需要注意\n3. 再浮动的元素后边添加一个空标签 clear:both;height:0;overflow:hidden\n    优点：简单快速，代码少，兼容性高\n    缺点：增加空标签，不利于页面优化\n4. 父级定义 overflow:auto\n    优点：简单快速，代码少，兼容性高\n    缺点：内部宽高超过父级div时，会出现滚动条\n5. 万能清除法：\n    给塌陷的元素添加伪对象\n          \t.father:after&#123;Content:&quot;随便写&quot;;Clear:both;Display:block;Height:0;Overflow:hidden;Visibility:hidden      &#125;\n        优点：写法固定，兼容性好\n        缺点：代码多\n\n","categories":["css"]},{"title":"如何让一个元素隐藏","url":"/2018/10/22/css/none/","content":"如何让一个元素隐藏\ndisplay:none;\nvisibility:hidden;\nbackground-color:transparent;或者设成与背景一样的颜色即可\nopacity来设置不透明级别，注意兼容性filter…\n给div一个margin负值，这个负值恰好等于div自身的高度或宽度\n设置两个大小一样的div，第一个左浮动，第二个不浮动，即可将第二个div隐藏\n设置一个父div和一个子div，子div绝对定位，父div相对定位，子div的left就是子div的宽度\n给父div1设置一个固定的宽度，给子div2设置的宽度远大于父div，并给父div1设置overflow:hidden,并给子div设置margin值即在父div1中没被隐藏的剩余宽度，代码如下：#div1&#123;width:100px;height:200px;overflow:hidden;&#125;#div2&#123;width:200px;height:200px;background:green;margin-left:100px;&#125;\n将div的宽度和高度设置为0\n\n","categories":["css"]},{"title":"vue响应式的理解","url":"/2020/07/30/vue/Responsive/","content":"所谓数据响应式就是数据发生变化可以被检测并对这种变化做出相应的机制MVVM框架中要解决的一个核心问题就是连接数据层和试图层，通过数据驱动视图应用，数据变化。视图更新要做到这一点就需要对数据做出响应式处理，这样一旦发生变化就可以立即做出处理更新Vue 通过数据响应式加上虚拟DOM和patch算法 可以使我们只需要操作数据，完全不需要接触繁琐的DOM操作，从而大大提高开发效率，降低开发难度在vue2中的数据响应式会根据数据类型来做不同处理如果是对象则采用object.defineproperty()的方式定义数据类型当数据被访问或发生变化时，感知并作出相应如果是数组则通过覆盖该数组的原型方法，扩展它的7个变更方法(pop,shift,push,unshift,splice,sort,reserve)，使这些方法可以额外的做更新通知，从而做出相应这种机制很好的解决了数据响应化的问题，但实际使用也存在一些缺点：    初始化时的递归遍历会造成性能损失    新增或删除属性时需要用户使用Vue.set/delete这样特殊的API才能生效    对于es6中新产生的Map，Set这些数据结构不支持等问题为了解决这些问题vue3重新编写    利用es6的proxy机制代理要响应化的数据    好处：        编程体验是一致的，不需要特殊的API        初始化新跟那个和内存的消耗得到了大幅的改善另外由于响应化的实现代码抽取为独立的reactivity包想完成这个过程，我们需要：\n\n侦测数据的变化\n收集视图依赖了哪些数据\n数据变化时，自动“通知”需要更新的视图部分，并进行更新对应专业俗语分别是：数据劫持 / 数据代理依赖收集发布订阅模式\n\n","categories":["vue"]},{"title":"nextTick","url":"/2020/07/16/vue/nextTick/","content":"nextTick是vue提供的一个全局的API\n由于vue的异步更新策略导致我们对数据的修改不会立即体现在dom变化上此时如果需要立即获取更新后的dom状态就需要这个方法\nvue在更新DOM是异步执行的，只要侦听到数据变化，vue将开启一个队列，并缓冲在同一时间循环中发生的所有数据变更如果一个watcher被触发多次 指挥推入到队列中一次，这种缓冲时去除重复数据对避免不必要的计算和DOM操作是非常重要的nextTick方法会在队列中加入一个函数，确保函数在前边的DOM操作完成后才调用，所以当我们想在修改数据后看到DOM执行结果就需要用到nextTick方法比如，我在干什么的时候就回使用nextTick，穿一个回调函数进去，在里边执行dom操作即可\n简单nextTick实现：在callbacks里边加入我们传入的回调函数，然后用setTimeout异步方式调用他们，\n异步首选就是Promise\n\n","categories":["vue"]},{"title":"vue和react区别","url":"/2021/04/24/Interview/vueReact/","content":"通常解法：vue采用的是指令结合vue-loader实现的构建用户界面的渐进式框架，\nreact是采用jsx构建用户界面的组件化开发\n\n通级大牛级解法在渲染用户界面的时候，Dom操作是最昂贵的，不幸的是没有库可以让这些原始操作变得更快。我们能做的最好就是，减少Dom的操作。Vue和React都是用虚拟Dom来实现。\n相同点：\n都支持服务端渲染\n都是用虚拟Dom来实现\n都有Virtual Dom（虚拟Dom）组件开发。通过props参数进行父子组件数据的传递 都实现webComponent规范\n只有框架的骨架，其他的功能如路由，状态管理等都是和框架分离的组件\n都是JavaScript的UI框架 数据驱动视图，专注于创造前端的富应用\n都支持native的方案（原生开发 开发一个东西 适配ndroid、iOS和Web应用），React的React native 和Vue的weex（快要淘汰）\n都有状态管理 React有redux Vue 有vuex（自适应vue量身定做）\n\n\n在React中，所有的组件的渲染功能使用的都是JSX JSX（JS+X）是使用XML语法编写JavaScript的语法糖,\n它可以使用完整的编程语言JavaScript来构建试图页面，工具对JSX的支持相比于现有可用的其他Vue模板还是比较先进的，\n在Vue中我们采用的Web技术并在其上边扩展，使用Template在写模板的过程中，样式风格已确定和更少的涉及业务逻辑，一个模板总是被声明的，\n模板中任何HTML都是有效的，相比之下，React功能没有Vue模板的丰富，需要从组件中分离出HTML代码。\n（也就是 React采用的是JSX，Vue采用的是Template React简单单调，Vue模板丰富）\n在性能方面，当我们考虑重新渲染功能。当组件的状态发生变化时，\nReact的机制会触发整个组件树的重新呈现，并且React有大量的检查机制，能让它提供许多有用的警告和错误的提示信息\n（例：在一个组件内部嵌套两个组件 孙子组件的Render重新渲染的时候 爷爷的组件也会跟着渲染 ，类似Angular的脏检查），\n但可能需要使用额外的属性来避免不必要的重新渲染子组件（生命周期钩子函数shouldComponentUpdate）\n虽然Vue的重新渲染是开箱即用的，但是Vue提供了优化的重新渲染，其系统在渲染的过程中跟踪依赖关系并相应的工作（发生改变的地方一旦改变，\n用到的地方跟着改变）\n\n\n在React中应用的状态是关键的概念，也有一些配套的框架被计为管理一个大的state对象，如redux此外 state对象在React应用中是不可变的，意味着他不能被直接改变（但是=赋值的时候是可以改变的，只是不会重新渲染页面），在React中需要使用setState()方法去更新状态在Vue中 state对象不是必须的，数据由data属性 在Vue对象中进行管理，而在Vue中，则不需要使用setState()之类的方法去改变状态，在Vue对象中data参数就是应用数据中的保存者\n不相同点：\nReact严格上只针对MVC的view层 Vue则是MVVM模式\nvirtual Dom不一样 Vue会跟踪每一个组件的依赖关系。则不需要重新渲染整个组件树\n而对于React而言，每当应用的状态发生改变时，全部的组件都会重新渲染，所以React中会需要shuouldComponentUpdate这个声明周期函数方法来进行控制\n组件的写法不一样，React推荐的是JSX+inline style 也就是把HTML 和css全部写进JS里边 （all in js）\nVue推荐的做法是webpack+vue-loader的单文件格式，即 html css js写在同一个文件\n数据绑定：Vue实现了数据的双向绑定 React数据流动是单向的\nstate对象在React应用是不可变的（不用setStae()试图不会更新），使用setState()方法更新状态\n在Vue中state对象不是必须的，数据是由data属性在Vue对象中管理应用场景：在以下场景中Vue比React更好： 最新文档和更简单的语法，更小更快，更灵活 丰富的HTML模板，易于开发\n\n在以下场景中React比Vue更好： 需要构建移动应用程序，专业和出色的社区支持，以解决任何问题，需要构建大型应用程序，轻量级，易于版本迁移\n\n\n\n","categories":["Interview"]},{"title":"router","url":"/2020/08/03/vue/router/","content":"在vue中路由主要有hash与History interface两种方式实现前端路由，单页路由的特点就是采用前端路由系统，通过改变URL，在不重新请求页面的情况下，更新页面视图。目前在浏览器环境中这一功能的实现主要有两种方式: hash和History\nHash:在浏览器的url中hash (“#”）符号的本来作用是加在URL中指示网页中的位置:#符号本身以及它后面的字符称之为hash，可通过window.location. hash属性读取。它具几个特点就是:hash虽然出现在URL中，但不会被包括在HTTP请求中。它是用来指导浏览器动作的，对服务器端完全无用，因此，改变hash不会重新加载页面，并且可以为hash的改变添加hashchange监听事件，在一个就是每一次改变hash(window.location. hash)，都会在浏览器的访问历史中增加一个记录，我就可以通过他的这几个特点实现一个hash模式的单页路由，通过对location.hash的修改实现\nHistory:采用了H5的新特性，history.interface提供了两个新的方法: pushState(),replaceState()使得我们对浏览器历史记录栈进行了修改以及popState事件可以监听到状态的变更\nHistory 的问题：对于单页面应用来讲，理想的使用场景是仅在进入应用时加载index.html，在后续的网络操作通过AJAx完成，不会很具URL重新请求页面，但是如果用户直接在地址栏中输入并回车，浏览器重启重新加载的时候history模式会将URL修改的就和正常请求后端的URL一样，在此情况下重新向后端发送请求，如果后端没有对应配置的路由处理,则会返回4O4报错，这种问题的解决，一般情况下都是在后端进行配置，将所有的路由请求都指向index.HTML文件\n","categories":["vue"]},{"title":"手动实现常见的JS源码","url":"/2020/11/28/js/all/","content":"手动实现常见的JS源码ES5实现call/*封装call*/Function.prototype.selfCall = function selfCall(context, ...args) &#123;  context || (context = window);  if (typeof this !==&#x27;function&#x27;) throw new TypeError(&#x27;selfCall is called must be a function&#x27;);  const fnc = this;  const caller = Symbol(&#x27;caller&#x27;);  context[caller] = fnc;  let res = context[caller](...args);  delete context[caller];  return res;&#125;;/** 看看call怎么用* 1. call是Function原型上面的一个方法* 2. call 函数参数 xxx.call(上下文,参数(可以有多个参数))   //xxx是一个函数* 3. 相当于执行xxx函数 只不过 传递了上下文对象 this* */function fn1 (cook)&#123;  console.log(this,cook);//window / node对象&#125;// fn1.call(&#123;obj:&#123;&#125;&#125;,&#x27;爆炒鱿鱼&#x27;);fn1.selfCall(&#123;obj:&#x27;lala&#x27;&#125;);\nES5实现bind/** 实现bind函数* */const selfBind = function (bindTarget, ...args1) &#123;  /*不是函数调用抛出错误*/  /*封装函数 如果没有绑定this则绑定 否则直接返回该函数*/  /*绑定原型*/  /*原型链绑定*/  /*返回该函数*/  /*1:*/  if (typeof this !== &#x27;function&#x27;) &#123;    throw new TypeError(&#x27;selfBind must be called a function&#x27;);  &#125;  /*2:*/  const func = this;  const boundFn = function (...args2) &#123;    const args = [...args1, ...args2];    if (new.target) &#123;      /*判断this必须是对象或者方法 */      let res = func.apply(this, args);      //new之后点出方法或者属性      if ((typeof res === &#x27;function&#x27; || typeof res === &#x27;object&#x27;) &amp;&amp; res !== null) return res;      return this;    &#125; else &#123;      func.apply(bindTarget, args);    &#125;    return func;  &#125;;  /*原型赋值*/  this.prototype &amp;&amp; (boundFn.prototype = Object.create(this.prototype));  /*原型链赋值*/  /*取出this中的所有原型链对象属性*/  let des = Object.getOwnPropertyDescriptors(func);  console.log(&#x27;des.length&#x27;,des.length);  Object.defineProperties(boundFn,&#123;    length: des.length,    name:Object.assign(des,&#123;      value:`bound$&#123;des.name.value&#125;`    &#125;)  &#125;);  return boundFn;&#125;;/** bind函数的使用* */let obj = &#123;  getName() &#123;    console.info(&#x27;Obj name&#x27;)  &#125;,  selfName: &#x27;Obj&#x27;&#125;;let obj2 = &#123;  getAge() &#123;    console.info(&#x27;Obj2 age&#x27;)  &#125;,  selfName: &#x27;Obj2&#x27;&#125;;function aaa(...args) &#123;  console.log(args);  // console.log(this, index, aa);  console.log(this);&#125;aaa.prototype.name = &#x27;zhangsan&#x27;;Object.prototype.selfBind = selfBind;let newAaa = aaa.selfBind(obj2, &#x27;张三&#x27;, &#x27;李四&#x27;, 123);console.log(new newAaa(1, &#x27;aa&#x27;).name);console.log(newAaa.prototype.name);//获取该对象或者方法自身属性的描述console.log(Object.getOwnPropertyDescriptors(newAaa));// newAaa();// new newAaa();// let aa = new newAaa(&#x27;王五&#x27;);// console.log(aa);// aa.selfBind(obj2)();//// let newAaa = aaa.bind(obj, &#x27;name&#x27;);// newAaa(&#x27;111&#x27;).getName();// console.log(aaa.__proto__ === newAaa.__proto__);/** 1:改变this指向* 2:是一个&#x27;函数&#x27;调用bind* 3:返回一个新的函数 但不执行 只有调用的时候才执行* 4:调用bind传入的参数  和真正调用函数的参数 有一个参数融合* 5:new 调用和普通调用* 6:原型属性是一样的* 7:原型链属性一致* */console.log(Function);\n简单实现Promsieclass myPromsie &#123;    constructor(cetor) &#123;        // 三个状态 等待 失败 成功        // 等待=》成功  等待=》失败 必须有一个结果        this.state = &quot;pending&quot; //等待        this.successFul = undefined        this.faild = undefined        // 定义执行的队列        this.resolveRrr = [] //成功的数组        try &#123;            cetor((...args) =&gt; &#123;                if (this.state == &quot;pending&quot;) &#123;                    // 修修改状态                    this.state = &quot;successFul&quot;                    this.successFul = args                    this.resolveRrr.forEach((fn) =&gt; &#123;                        fn.onResolve(this.successFul)                    &#125;)                &#125;            &#125;, (...args) =&gt; &#123;                if (this.state == &quot;pending&quot;) &#123;                    // 修修改状态                    this.state = &quot;faild&quot;                    this.faild = args                    this.resolveRrr.forEach((fn) =&gt; &#123;                        fn.onReject(this.faild)                    &#125;)                &#125;            &#125;)        &#125; catch (error) &#123;        &#125;    &#125;    then(onResolve, onReject) &#123;        if (this.state == &quot;pending&quot;) &#123;            // 对象形式传进去            this.resolveRrr.push(&#123;                onResolve,                onReject            &#125;)        &#125; else if (this.state == &quot;successFul&quot;) &#123;            onResolve(this.successFul)        &#125; else if (this.state == &quot;faild&quot;) &#123;            onReject(this.faild)        &#125;    &#125;&#125;\t\t\tlet aa = new myPromsie((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;        // resolve(&#x27;田百万&#x27;)        reject(&quot;asd&quot;)    &#125;, 1000);&#125;)aa.then((res) =&gt; &#123;    console.log(res);&#125;, (err) =&gt; &#123;    console.log(err);&#125;)\n查找对应括号 var fun = function (num) &#123;    let items = []    let numLength = num.length    // 先判断 有没有多余的括号    if (numLength % 2 != 0) &#123;        return false    &#125;    // 遍历整个字符串    for (let a = 0; a &lt; numLength; a++) &#123;        let newNum = items[items.length - 1]        // 23 14 05         switch (num[a]) &#123;            // 判断依次push            case &#x27;(&#x27;:                items.push(&#x27;(&#x27;) //放到栈里边                break            case &#x27;[&#x27;:                items.push(&#x27;[&#x27;)                break            case &#x27;&#123;&#x27;:                items.push(&#x27;&#123;&#x27;)                break            case &quot;)&quot;:                if (newNum == &#x27;(&#x27;) &#123;                    items.pop() //一样的话就丢出来                &#125;                break            case &quot;]&quot;:                if (newNum == &#x27;[&#x27;) &#123;                    items.pop()                &#125;                break            case &quot;&#125;&quot;:                if (newNum == &#x27;&#123;&#x27;) &#123;                    items.pop()                &#125;                break        &#125;    &#125;    return items.length == 0&#125;let aa = &#x27;(]&#x27;let str = &#x27;[&#123;()()&#123;&#125;&#125;]&#x27;let bb = &#x27;[&#125;&#x27;let cc = &#x27;()&#x27;console.log(fun(str));console.log(fun(bb));console.log(fun(cc));\n\n手写深拷贝let obj = &#123;      name: &quot;田林汇&quot;,      age: &quot;20&quot;,      colors: [&quot;yellow&quot;, &quot;blue&quot;],      friends: &#123;          name: &quot;刀哥&quot;      &#125;  &#125;  function cloneDeep(obj) &#123;      if (typeof obj !== &quot;object&quot; || obj == null) &#123;          return obj      &#125;      let result;      if(obj instanceof Array)&#123; //如果传入的是个数组          result=[]//默认给个数组      &#125;else&#123;          result=&#123;&#125;      &#125;      for (const key in obj) &#123;          // 只访问对象自身的属性          if (obj.hasOwnProperty( key)) &#123;             result[key]=cloneDeep(obj[key])                        &#125;      &#125;      return result  &#125;  let obj1 = cloneDeep(obj)  obj1.name=&quot;huihui&quot;  obj1.friends.name=&quot;huihui&quot;  console.log(obj1);\n\n请求失败重连function requestAgain(request,port,time,params)&#123; //传递的参数 时间和次数    // await后边跟着的是一个Promise    return new Promise((resolve,reject)=&gt;&#123;        // 在这里边要执行的操作就是 不但的执行request请求 直到成功或者达到上限为止        // 写一个函数 这里边是要执行的操作        function excutePromise(timer)&#123;            // 1.判断次数            if(port&lt;1)&#123;                // 1.1清除定时器                clearInterval(timer)                // 1.2调用reject 抛出一个错误                reject(new TypeError(&quot;promise not until timeout&quot;))                // 1.3 return 一个undefined                return void 0; //void 0 就是undefined            &#125;            port-=1 //每执行一次的时候让次数减一            // 2 等待成功            let  &#123;url,args&#125;=params //这是传的参数            return request(url,args).then((res)=&gt;&#123;                clearInterval(timer) //成功以后清除定时器                resolve(res)            &#125;).catch((e)=&gt;&#123;                throw new TypeError(e) //有错误就抛出错误            &#125;)        &#125;        // 定时器 隔一段时间就会执行        let timer=setInterval(() =&gt; &#123;            excutePromise(timer)         &#125;, time);        // 一进来就执行一次            excutePromise(timer)    &#125;) &#125;\n\n封装co模块// 封装一个co模块 function run(generator) &#123;     let gen = generator() //执行了这个generator函数     // console.log(gen);     //结合next 结合done     // 主要思想是递归     function next(data) &#123; //接受的参数         let result = gen.next(data) //从实例中取出来 value 和done &#123;value，done&#125;         if (result.done) return result.value //true 的话就是执行完了         // 必须在第一次的继承上 才能调用此三次的递归         if (result.value instanceof Promise) &#123; //证明这个值是promise的实例才会走  看50行yiled后边跟的             result.value.then((newData) =&gt; &#123;                 next(newData) //递归             &#125;)         &#125; else &#123;             throw new TypeError(&quot;after yiled params must be a instanceof Promise&quot;)         &#125;     &#125;     next() &#125; function getAsyncResult() &#123;     return new Promise((resolve, reject) =&gt; &#123;         setTimeout(() =&gt; &#123;             resolve(&quot;111&quot;)         &#125;, 0)     &#125;) &#125; function getAsyncResult1() &#123;     return new Promise((resolve, reject) =&gt; &#123;         setTimeout(() =&gt; &#123;             resolve(&quot;222&quot;)         &#125;, 0)     &#125;) &#125; function* fn() &#123;     let res = yield getAsyncResult()     let res1 = yield getAsyncResult1()   //   console.log(res);   //   console.log(res1); &#125; run(fn)\npromise封装AJAX请求class $request &#123;        ajax(url, method, data, type) &#123;            return new Promise((resolve, reject) =&gt; &#123;                // 创建兼容xmlrequest对象                const xhr = new XMLHttpRequest()                // 添加请求事件并且监听                xhr.onreadystatechange = function () &#123;                    var res                    // 判断状态码                    if (xhr.status === 200 &amp;&amp; xhr.readyState == 4) &#123; //成功                        // 根据类型判断 做怎样的处理                        if (type == &quot;json&quot;) &#123;                            res = JSON.parse(xhr.responseText)                        &#125; else if (type == &quot;xml&quot;) &#123;                            res = responseXML                        &#125; else &#123;                            res = xhr.responseText                        &#125;                        resolve(res)                    &#125;                &#125;                xhr.onerrer = function () &#123;                    reject(xhr.statusText)                &#125;                let param = &#x27;&#x27;                // 判断data是否有数据                if (JSON.stringify(data) !== &#x27;&#123;&#125;&#x27;) &#123;                    url += &#x27;?&#x27;                    for (var i in data) &#123;                        param += i + &#x27;=&#x27; + data[i] + &#x27;&amp;&#x27; // 将js对象重组，拼接成url参数存入param变量中                    &#125;                    // 使用slice函数提取一部分字符串，这里主要是为了去除拼接的最后一个&amp;字符                    param = param.slice(0, param.length - 1)                &#125;                // 判断请求方式                if (method === &#x27;get&#x27;) &#123;                    // 是则将数据拼接在url后面                    url = url + param                &#125;                // 初始化请求                xhr.open(method, url, true)                if (method == &quot;post&quot;) &#123;                    // xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;) // 设置请求头                    xhr.send(JSON.stringify(data)) //发送请求                &#125; else &#123;                    xhr.send(null)                &#125;            &#125;)        &#125;    &#125;    let $ = new $request()    let newData = &#123;        name: &quot;辉辉&quot;,        age: &quot;12&quot;    &#125;    // console.log($.ajax);    document.querySelector(&#x27;.btn1&#x27;).onclick = () =&gt; &#123;        $.ajax(&quot;http://localhost:3000/list&quot;, &#x27;get&#x27;, newData, &#x27;json&#x27;).then(res =&gt; &#123;            console.log(res);        &#125;).catch(err =&gt; &#123;            console.log(err);        &#125;)    &#125;\n原生继承//缺点：//父类的构造没有执行 不能传参function Parent() &#123;&#125;    Parent.prototype.sayHui = function () &#123;        console.log(&quot;我是千树辉&quot;);    &#125;    function Child() &#123;&#125;    Child.prototype.sayYang = function () &#123;        console.log(&#x27;我是阳阳&#x27;);    &#125;    // Child.prototype.__proto__ = Parent.prototype    Child.prototype.__proto__ = new Parent()    let Son = new Child()    Son.sayHui()\n组合继承//优点：可以继承父类的原型内容 也不会造成原型里边的属性修改//缺点：//让parent的构造执行了两次 出现了undefined  function Parent(name) &#123;        this.Parentname=name    &#125;    Parent.prototype.sayHui = function () &#123;        console.log(&quot;我是千树辉&quot;);    &#125;    function Child(name) &#123;        Parent.call(this,name)        this.Childname=name    &#125;      Child.prototype.sayYang = function () &#123;        console.log(&#x27;我是阳阳&#x27;);    &#125;    Child.prototype.__proto__ = new Parent()    let Son = new Child(&quot;hui&quot;)    console.log(Son.Parentname);\n组合寄生继承function Parent(name) &#123;    this.Parentname = name&#125;Parent.prototype.sayHui = function () &#123;    console.log(&quot;我是千树辉&quot;);&#125;function Child(name) &#123;    Parent.call(this, name)    this.Childname = name&#125;Child.prototype.sayYang = function () &#123;    console.log(&#x27;我是阳阳&#x27;);&#125; Child.prototype.__proto__ = Object.create(Parent.prototype)//浅拷贝创建一个对象let Son = new Child(&quot;hui&quot;)console.log(Son.Parentname);","categories":["js"]}]